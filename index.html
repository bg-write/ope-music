<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPE! - Music Reviews by Brady Gerber</title>
    <meta name="description" content="Music sucks.">
    <meta name="keywords" content="music discovery, song of the week, music recommendations, indie music, new music">
    <meta name="author" content="Brady Gerber">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="OPE! - Music Reviews by Brady Gerber">
    <meta property="og:description" content="Music sucks.">
    <meta property="og:type" content="website">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OPE! - Music Reviews by Brady Gerber">
    <meta name="twitter:description" content="Music sucks.">
    
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
</head>
<body>
    <!-- Skip Navigation Link for Screen Readers -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Header Section with logo and tagline -->
    <!-- Contains the main title, subtitle, and animated logo image -->
    <header class="header-content" role="banner">
        <div class="header-text">
            <h1>OPE!</h1>
            <p>Music reviews by Brady Gerber</p>
            <p>Fueled by corn and spite</p>
        </div>
        <div class="header-image">
            <img src="images/logo.png" alt="OPE! Logo - Animated music note icon" class="logo">
        </div>
    </header>

    <!-- Navigation tabs for switching between different content sections -->
    <!-- Each tab loads content dynamically without page refresh -->
    <nav class="nav" role="navigation" aria-label="Main navigation">
        <a href="#" onclick="showContent('free')" id="free-link" role="tab" aria-selected="true" aria-controls="content-container">Songs</a>
        <a href="#" onclick="showContent('newsletter')" id="newsletter-link" role="tab" aria-selected="false" aria-controls="content-container">Newsletter</a>
        <a href="#" onclick="showContent('podcast')" id="podcast-link" role="tab" aria-selected="false" aria-controls="content-container">Podcast</a>
        <!-- <a href="#" onclick="showContent('email')" id="email-link" role="tab" aria-selected="false" aria-controls="content-container">Email</a> -->
        <!-- <a href="#" onclick="showContent('albums')" id="albums-link" role="tab" aria-selected="false" aria-controls="content-container">Album Reviews</a> -->
        <!-- <a href="#" onclick="showContent('members')" id="members-link" role="tab" aria-selected="false" aria-controls="content-container">Exclusive Member Content</a> -->
    </nav>

    <!-- Content Container - dynamically populated by JavaScript -->
    <!-- Content is loaded from the 'content' object below, which gets updated by build.js -->
    <main id="main-content" role="main" aria-live="polite" aria-label="Page content">
        <div id="content-container">
            <!-- Content will be loaded here dynamically -->
            <p>Content will be loaded from Markdown files...</p>
        </div>
    </main>

    <!-- Data Quality Modal -->
    <div id="data-quality-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìä Data Quality Dashboard</h2>
                <button class="modal-close" onclick="closeDataQualityModal()" aria-label="Close modal">√ó</button>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Modal content will be populated here -->
            </div>
        </div>
    </div>

    <!-- Floating Back to Top Button -->
    <button id="back-to-top" class="back-to-top-btn" aria-label="Back to top of page" title="Back to top">
        ‚Üë
    </button>

    <script>
        // API Configuration
        const API_BASE = 'https://ope-music.netlify.app/api';
        
        // Global data storage
        let reviewsData = [];
        
        // Data validation utilities
        const DataValidator = {
            sanitizeText: (text) => {
                if (typeof text !== 'string') return '';
                return text.replace(/[<>]/g, '').trim();
            },
            
            validateReview: (review) => {
                const errors = [];
                
                if (!review.song_title || review.song_title.trim().length === 0) {
                    errors.push('Missing song title');
                }
                if (!review.song_artist || review.song_artist.trim().length === 0) {
                    errors.push('Missing artist name');
                }
                if (!review.review_score || !/^\d+(\.\d+)?\/\d+$/.test(review.review_score)) {
                    errors.push(`Invalid review score format: "${review.review_score}"`);
                }
                
                // More flexible date validation - accept various formats
                if (!review.review_date) {
                    errors.push('Missing review date');
                } else {
                    // Accept formats like: "August 20, 2025", "2025-08-20", "8/20/2025"
                    const dateFormats = [
                        /^[A-Za-z]+ \d{1,2}, \d{4}$/, // "August 20, 2025"
                        /^\d{4}-\d{2}-\d{2}$/, // "2025-08-20"
                        /^\d{1,2}\/\d{1,2}\/\d{4}$/ // "8/20/2025"
                    ];
                    
                    const isValidDate = dateFormats.some(format => format.test(review.review_date));
                    if (!isValidDate) {
                        errors.push(`Invalid date format: "${review.review_date}"`);
                    }
                }
                
                return { isValid: errors.length === 0, errors };
            },
            
            sanitizeReview: (review) => {
                return {
                    ...review,
                    song_title: DataValidator.sanitizeText(review.song_title),
                    song_artist: DataValidator.sanitizeText(review.song_artist),
                    review_text: DataValidator.sanitizeText(review.review_text),
                    song_url: review.song_url || '',
                    review_id: review.review_id || ''
                };
            }
        };
        
        // Analytics tracking
        let analyticsData = {
            pageViews: {},
            searches: [],
            reviewClicks: [],
            apiErrors: [],
            dataQualityIssues: [],
            performanceMetrics: {
                apiResponseTimes: [],
                errorRates: 0,
                totalRequests: 0
            },
            sessionStart: new Date().toISOString()
        };
        
        // Content data - Now dynamically populated from API
        let content = {
            free: { title: "Songs", html: '<div class="section"><p>Loading reviews...</p></div>' },
            newsletter: { title: "Newsletter", html: `<div class="section">
        <p>A link to the week's reviews every Friday, along with other "fun" links and "musings" on "life": <a href="https://bradygerber.com/newsletter/" target="_blank" rel="noopener">https://bradygerber.com/newsletter/</a></p>
    </div>` },
            podcast: { title: "Podcast", html: `<div class="section">
        <p>My reviews, but easier to understand: <a href="https://bradygerber.com/podcast-and-youtube/" target="_blank" rel="noopener">https://bradygerber.com/podcast-and-youtube/</a></p>
    </div>` },

        };

        /**
         * Convert numeric rating to 4-star display using Roger Ebert's method
         * @param {string} rating - Rating string (e.g., "3.5/4")
         * @returns {string} HTML string with 4 stars
         */
        function generateStarRating(rating) {
            // Parse the rating (e.g., "3.5/4" -> 3.5 out of 4)
            const ratingMatch = rating.match(/(\d+(?:\.\d+)?)\/(\d+)/);
            if (!ratingMatch) return rating; // Fallback to original if can't parse
            
            const score = parseFloat(ratingMatch[1]);
            const maxScore = parseInt(ratingMatch[2]);
            
            // Convert to 4-star scale
            const fourStarScore = (score / maxScore) * 4;
            
            // Create star rating container with Roger Ebert's approach
            const starsHTML = `
                <div class="star-box" title="${rating}">
                    <div class="stars-empty">‚òÜ‚òÜ‚òÜ‚òÜ</div>
                    <div class="stars-filled" style="width: ${(fourStarScore / 4) * 100}%">‚òÖ‚òÖ‚òÖ‚òÖ</div>
                </div>
            `;
            
            return starsHTML;
        }

        /**
         * Generate HTML for a song review entry
         * @param {Object} song - Song review data from API
         * @param {string} song.song_title - Title of the song
         * @param {string} song.song_artist - Name of the artist
         * @param {string} song.review_score - Rating (e.g., "3.5/4")
         * @param {string} song.review_date - Date of the review
         * @param {string} song.review_text - Review description
         * @param {string} song.song_url - URL to listen to the song
         * @param {string} song.review_id - Unique identifier for the review
         * @returns {string} HTML string for the song entry
         */
        function generateSongHTML(song) {
            return `
            <div class="song-entry" id="${song.review_id}" data-artist="${song.song_artist.toLowerCase()} ${song.song_title.toLowerCase()}">
                <h3 class="song-title">${song.song_artist} - "${song.song_title}"</h3>
                <div class="song-rating">${generateStarRating(song.review_score)}</div>
                <p class="song-date">${song.review_date}</p>
                <p class="song-description">${song.review_text}</p>
                <div class="song-links">
                    <a href="${song.song_url}" target="_blank" rel="noopener">Listen</a>
                </div>
            </div>`;
        }

        /**
         * Generate HTML for a link entry (future feature)
         * @param {Object} link - Link data from API
         * @param {string} link.title - Title of the link
         * @param {string} link.date - Date of the link
         * @param {string} link.description - Description of the link
         * @param {string} link.url - URL to the link
         * @returns {string} HTML string for the link entry
         */


        /**
         * Generate data quality dashboard HTML
         * Shows validation statistics and download options
         */
        function generateDataQualityDashboard() {
            if (!reviewsData || reviewsData.length === 0) {
                return '<div class="section"><p>No data available for quality analysis.</p></div>';
            }
            
            // Calculate validation statistics
            const totalReviews = reviewsData.length;
            const validationResults = {
                total: totalReviews,
                valid: 0,
                invalid: 0,
                issues: []
            };
            
            reviewsData.forEach((review, index) => {
                const validation = DataValidator.validateReview(review);
                if (validation.isValid) {
                    validationResults.valid++;
                } else {
                    validationResults.invalid++;
                    validationResults.issues.push({
                        index,
                        errors: validation.errors
                    });
                }
            });
            
            const qualityScore = ((validationResults.valid / validationResults.total) * 100).toFixed(1);
            
            return `
                <div class="section">
                    <h2>üìä Data Quality Dashboard</h2>
                    <p>Monitor the health and integrity of your review data.</p>
                    
                    <div class="data-quality-stats">
                        <div class="stat-card">
                            <h3>Total Reviews</h3>
                            <p class="stat-number">${validationResults.total}</p>
                        </div>
                        <div class="stat-card">
                            <h3>Valid Reviews</h3>
                            <p class="stat-number valid">${validationResults.valid}</p>
                        </div>
                        <div class="stat-card">
                            <h3>Data Quality Score</h3>
                            <p class="stat-number">${qualityScore}%</p>
                        </div>
                    </div>
                    
                    <div class="download-section">
                        <h3>üì• Data Downloads</h3>
                        <div class="download-options">
                            <div class="download-option">
                                                                  <h4>üöÄ BigQuery Ready CSV</h4>
                                  <p>Comprehensive data with all metadata fields for analysis</p>
                                <button onclick="exportCleanCSV()" class="download-btn">Download Comprehensive CSV</button>
                            </div>
                            <div class="download-option">
                                <h4>üìã Full Report CSV</h4>
                                <p>Includes data quality metadata and validation status</p>
                                <button onclick="exportReviewsCSV()" class="download-btn">Download Full Report with Quality</button>
                            </div>
                            <div class="download-option">
                                <h4>üìà Analytics Data</h4>
                                <p>User behavior and performance metrics</p>
                                <button class="download-btn coming-soon" disabled>Coming Soon!</button>
                            </div>
                        </div>
                    </div>
                    
                    ${validationResults.issues.length > 0 ? `
                        <div class="data-issues-section">
                            <h3>‚ö†Ô∏è Data Quality Issues</h3>
                            <p>Found ${validationResults.issues.length} reviews with validation issues:</p>
                            <div class="issues-list">
                                ${validationResults.issues.map(issue => `
                                    <div class="issue-item">
                                        <strong>Review ${issue.index + 1}:</strong> ${issue.errors.join(', ')}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : `
                        <div class="data-issues-section">
                            <h3>‚úÖ All Data Validated</h3>
                            <p>Great job! All ${validationResults.total} reviews passed validation checks.</p>
                        </div>
                    `}
                </div>
            `;
        }

        /**
         * Update the content object with data from the API
         * Generates HTML for songs and links, updates footer date
         */
        function updateContentFromAPI() {
            // Update Songs tab (free)
            if (reviewsData.length > 0) {
                const songsHTML = `
                <div class="section">
                    <div class="search-section">
                        <input type="text" id="song-search" placeholder="Search for artist or song..." onkeyup="searchSongs()">
                        <p class="search-help">Type a song title (e.g., "Like a Rolling Stone") or artist name to search</p>
                    </div>
                    ${reviewsData.map(song => generateSongHTML(song)).join('')}
                </div>`;
                content.free.html = songsHTML;
            }



            // Update footer date with most recent review date
            if (reviewsData.length > 0) {
                const mostRecentReview = reviewsData[0]; // First review is most recent
                const lastUpdatedSpan = document.getElementById('last-updated-date');
                if (lastUpdatedSpan) {
                    lastUpdatedSpan.textContent = mostRecentReview.review_date;
                }
            }
            
            // Add subtle animation to new content
            setTimeout(() => {
                const songEntries = document.querySelectorAll('.song-entry');
                songEntries.forEach((entry, index) => {
                    entry.style.opacity = '0';
                    entry.style.transform = 'translateY(20px)';
                    entry.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                    
                    setTimeout(() => {
                        entry.style.opacity = '1';
                        entry.style.transform = 'translateY(0)';
                    }, index * 50); // Stagger the animation
                });
            }, 100);
        }

        /**
         * Fetch review data from the API and update the UI
         * Handles loading states, error handling, and content updates
         * @returns {Promise<void>}
         */
        async function fetchDataFromAPI() {
            try {
                // Show loading state
                content.free.html = '<div class="section"><p>üîÑ Loading reviews from API...</p></div>';

                
                // Refresh current tab to show loading
                const currentTab = document.querySelector('.nav a[aria-selected="true"]');
                if (currentTab) {
                    const currentPage = currentTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                    showContent(currentPage);
                }

                // Fetch reviews
                const reviewsResponse = await fetch(`${API_BASE}/reviews`);
                if (!reviewsResponse.ok) {
                    throw new Error(`HTTP ${reviewsResponse.status}: ${reviewsResponse.statusText}`);
                }
                
                const reviewsResult = await reviewsResponse.json();
                reviewsData = reviewsResult.reviews || [];
                
                // Validate and sanitize all reviews
                const rawReviews = reviewsResult.reviews || [];
                const validatedReviews = [];
                const dataQualityIssues = [];
                
                rawReviews.forEach((review, index) => {
                    const validation = DataValidator.validateReview(review);
                    if (validation.isValid) {
                        validatedReviews.push(DataValidator.sanitizeReview(review));
                    } else {
                        dataQualityIssues.push({
                            reviewIndex: index,
                            errors: validation.errors,
                            review: review
                        });
                        // Only log significant data quality issues
                        if (validation.errors.length > 1) {
                            // console.warn(`Data quality issue in review ${index}:`, validation.errors);
                        }
                    }
                });
                
                // Store validated data (fallback to raw if all validation fails)
                if (validatedReviews.length > 0) {
                    reviewsData = validatedReviews;
                    // console.log(`‚úÖ Loaded ${validatedReviews.length} validated reviews`);
                } else {
                    // console.warn('‚ö†Ô∏è No reviews passed validation, falling back to raw data');
                    reviewsData = rawReviews;
                }
                
                // Track data quality issues
                if (dataQualityIssues.length > 0) {
                    analyticsData.dataQualityIssues.push(...dataQualityIssues);
                    // console.warn(`‚ö†Ô∏è Found ${dataQualityIssues.length} data quality issues`);
                }



                // Update content with API data
                updateContentFromAPI();

                // If we're on a tab that needs to refresh, refresh it
                if (currentTab) {
                    const currentPage = currentTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                    showContent(currentPage);
                }

                // API data loaded successfully
            } catch (error) {
                // Track error analytics
                analyticsData.apiErrors.push({
                    timestamp: new Date().toISOString(),
                    error: error.message,
                    stack: error.stack
                });
                
                // Show user-friendly error message
                showErrorMessage('Failed to load reviews. Please try again later.');
            }
        }

        // Function to show content
        function showContent(page) {
            const container = document.getElementById('content-container');
            const freeLink = document.getElementById('free-link');
            const newsletterLink = document.getElementById('newsletter-link');
            const podcastLink = document.getElementById('podcast-link');
            
            // Track page view for analytics
            if (!analyticsData.pageViews[page]) {
                analyticsData.pageViews[page] = 0;
            }
            analyticsData.pageViews[page]++;
            
            // Save analytics data
            saveAnalyticsData();
            
            // Update content
            container.innerHTML = content[page].html;
            
            // Update navigation styling and ARIA states
            freeLink.classList.remove('active');
            freeLink.setAttribute('aria-selected', 'false');
            newsletterLink.classList.remove('active');
            newsletterLink.setAttribute('aria-selected', 'false');
            podcastLink.classList.remove('active');
            podcastLink.setAttribute('aria-selected', 'false');
            
            if (page === 'free') {
                freeLink.classList.add('active');
                freeLink.setAttribute('aria-selected', 'true');
            } else if (page === 'newsletter') {
                newsletterLink.classList.add('active');
                newsletterLink.setAttribute('aria-selected', 'true');
            } else if (page === 'podcast') {
                podcastLink.classList.add('active');
                podcastLink.setAttribute('aria-selected', 'true');
            }
            
            // Update page title
            document.title = `OPE! - ${content[page].title}`;
            
            // Announce page change to screen readers
            announcePageChange(content[page].title);
        }
        
        // Function to announce page changes to screen readers
        function announcePageChange(pageTitle) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = `Switched to ${pageTitle} page`;
            
            document.body.appendChild(announcement);
            
            // Remove after announcement
            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }
        
        /**
         * Save analytics data to localStorage
         */
        function saveAnalyticsData() {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem('opeAnalytics', JSON.stringify(analyticsData));
            }
        }
        
        /**
         * Load analytics data from localStorage
         */
        function loadAnalyticsData() {
            if (typeof localStorage !== 'undefined') {
                try {
                    const saved = localStorage.getItem('opeAnalytics');
                    if (saved) {
                        analyticsData = JSON.parse(saved);
                    }
                } catch (error) {
                    // Reset analytics data if parsing fails
                    analyticsData = getDefaultAnalyticsData();
                }
            }
        }
        
        /**
         * Export analytics data as CSV for SQL practice
         */
        function exportAnalyticsCSV() {
            const csvData = [];
            csvData.push('event_type,value,count,timestamp,details');
            
            // Page views data
            Object.entries(analyticsData.pageViews).forEach(([page, count]) => {
                csvData.push(`page_view,${page},${count},${analyticsData.sessionStart},`);
            });
            
            // Search data
            analyticsData.searches.forEach(search => {
                csvData.push(`search,${search.term},${search.results || 1},${search.timestamp},`);
            });
            
            // Review clicks data
            analyticsData.reviewClicks.forEach(click => {
                csvData.push(`review_click,${click.reviewId || click.songTitle},1,${click.timestamp},`);
            });
            
            // API errors
            analyticsData.apiErrors.forEach(error => {
                csvData.push(`api_error,${error.error},1,${error.timestamp},${error.stack}`);
            });
            
            // Data quality issues
            analyticsData.dataQualityIssues.forEach(issue => {
                csvData.push(`data_quality_issue,review_${issue.reviewIndex},1,${new Date().toISOString()},${issue.errors.join(', ')}`);
            });
            
            // Performance metrics
            if (analyticsData.performanceMetrics.apiResponseTimes.length > 0) {
                const avgResponseTime = analyticsData.performanceMetrics.apiResponseTimes.reduce((a, b) => a + b, 0) / analyticsData.performanceMetrics.apiResponseTimes.length;
                csvData.push(`performance_metric,average_response_time,${avgResponseTime.toFixed(2)},${new Date().toISOString()},ms`);
            }
            
            csvData.push(`performance_metric,error_rate,${analyticsData.performanceMetrics.errorRates},${new Date().toISOString()},percentage`);
            csvData.push(`performance_metric,total_requests,${analyticsData.performanceMetrics.totalRequests},${new Date().toISOString()},percentage`);
            
            const csv = `event_type,value,count,timestamp,details\n${csvData.join('\n')}`;
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ope_enhanced_analytics_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        /**
         * Export clean CSV for BigQuery (no metadata rows)
         */
        async function exportCleanCSV() {
            try {
                const response = await fetch('https://ope-music.netlify.app/.netlify/functions/reviews');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const reviews = data.reviews || [];
                
                if (reviews.length === 0) {
                    alert('No reviews found to export');
                    return;
                }
                
                // Create comprehensive CSV with all metadata fields
                const csvData = [];
                
                // Add header row with all metadata fields
                csvData.push('song_title,song_artist,song_release_date,song_upload_date,song_duration_sec,song_album,song_label,song_genre,song_mood,song_instrumentation,song_language,song_audio_url,review_date,review_score,review_text,review_id');
                
                // Add each review as a row
                reviews.forEach((review, index) => {
                    // Clean and escape all text fields for CSV
                    const cleanText = (review.review_text || '').replace(/"/g, '""').replace(/\n/g, ' ');
                    const cleanTitle = (review.song_title || '').replace(/"/g, '""');
                    const cleanArtist = (review.song_artist || '').replace(/"/g, '""');
                    const cleanAlbum = (review.song_album || '').replace(/"/g, '""');
                    const cleanLabel = (review.song_label || '').replace(/"/g, '""');
                    const cleanGenre = (review.song_genre || '').replace(/"/g, '""');
                    const cleanMood = (review.song_mood || '').replace(/"/g, '""');
                    const cleanInstrumentation = (review.song_instrumentation || '').replace(/"/g, '""');
                    
                    // Convert review score to proper decimal format (1/4 -> 1.0, 0.5/4 -> 0.5)
                    let reviewScore = review.review_score;
                    if (reviewScore && typeof reviewScore === 'string' && reviewScore.includes('/')) {
                        const [numerator, denominator] = reviewScore.split('/');
                        if (denominator === '4') {
                            reviewScore = parseFloat(numerator).toFixed(1);
                        }
                    }
                    
                    csvData.push(`"${cleanTitle}","${cleanArtist}","${review.song_release_date || ''}","${review.song_upload_date || ''}","${review.song_duration_sec || ''}","${cleanAlbum}","${cleanLabel}","${cleanGenre}","${cleanMood}","${cleanInstrumentation}","${review.song_language || ''}","${review.song_audio_url || ''}","${review.review_date || ''}","${reviewScore || ''}","${cleanText}","${review.review_id || ''}"`);
                });
                
                const csv = csvData.join('\n');
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ope_reviews_comprehensive_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                // Track export analytics
                analyticsData.performanceMetrics.totalRequests++;
                saveAnalyticsData();
                
            } catch (error) {
                // Track error analytics
                analyticsData.performanceMetrics.totalRequests++;
                saveAnalyticsData();
                
                alert('Failed to export comprehensive CSV. Please try again.');
            }
        }

        /**
         * Export review metadata as CSV for data analysis
         */
        async function exportReviewsCSV() {
            try {
                // Fetch the latest review data from your API
                const response = await fetch('https://ope-music.netlify.app/.netlify/functions/reviews');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const reviews = data.reviews || [];
                
                if (reviews.length === 0) {
                    alert('No reviews found to export');
                    return;
                }
                
                // Create comprehensive CSV with all metadata fields and data quality
                const csvData = [];
                
                // Add header row with all metadata fields plus data quality
                csvData.push('song_title,song_artist,song_release_date,song_upload_date,song_duration_sec,song_album,song_label,song_genre,song_mood,song_instrumentation,song_language,song_audio_url,review_date,review_score,review_text,review_id,data_quality_status');
                
                // Track validation results
                const validationResults = {
                    total: reviews.length,
                    valid: 0,
                    invalid: 0,
                    issues: []
                };
                
                // Add each review as a row
                reviews.forEach((review, index) => {
                    // Validate review data
                    const validation = DataValidator.validateReview(review);
                    const isValid = validation.isValid;
                    
                    if (isValid) {
                        validationResults.valid++;
                    } else {
                        validationResults.invalid++;
                        validationResults.issues.push({
                            index,
                            errors: validation.errors
                        });
                    }
                    
                    // Clean and escape all text fields for CSV
                    const cleanText = (review.review_text || '').replace(/"/g, '""').replace(/\n/g, ' ');
                    const cleanTitle = (review.song_title || '').replace(/"/g, '""');
                    const cleanArtist = (review.song_artist || '').replace(/"/g, '""');
                    const cleanAlbum = (review.song_album || '').replace(/"/g, '""');
                    const cleanLabel = (review.song_label || '').replace(/"/g, '""');
                    const cleanGenre = (review.song_genre || '').replace(/"/g, '""');
                    const cleanMood = (review.song_mood || '').replace(/"/g, '""');
                    const cleanInstrumentation = (review.song_instrumentation || '').replace(/"/g, '""');
                    
                    // Convert review score to proper decimal format (1/4 -> 1.0, 0.5/4 -> 0.5)
                    let reviewScore = review.review_score;
                    if (reviewScore && typeof reviewScore === 'string' && reviewScore.includes('/')) {
                        const [numerator, denominator] = reviewScore.split('/');
                        if (denominator === '4') {
                            reviewScore = parseFloat(numerator).toFixed(1);
                        }
                    }
                    
                    const qualityStatus = isValid ? 'VALID' : `INVALID: ${validation.errors.join(', ')}`;
                    csvData.push(`"${cleanTitle}","${cleanArtist}","${review.song_release_date || ''}","${review.song_upload_date || ''}","${review.song_duration_sec || ''}","${cleanAlbum}","${cleanLabel}","${cleanGenre}","${cleanMood}","${cleanInstrumentation}","${review.song_language || ''}","${review.song_audio_url || ''}","${review.review_date || ''}","${reviewScore || ''}","${cleanText}","${review.review_id || ''}","${qualityStatus}"`);
                });
                
                // Add data quality summary at the top
                csvData.unshift(`# Data Quality Report - ${new Date().toISOString()}`);
                csvData.unshift(`# Total Reviews: ${validationResults.total}, Valid: ${validationResults.valid}, Invalid: ${validationResults.invalid}`);
                if (validationResults.issues.length > 0) {
                    csvData.unshift(`# Issues Found: ${validationResults.issues.map(i => `Review ${i.index}: ${i.errors.join(', ')}`).join('; ')}`);
                }
                csvData.unshift('');
                
                // Create and download CSV with proper headers
                const csv = csvData.join('\n');
                const blob = new Blob(['\ufeff' + csv], { 
                    type: 'text/csv;charset=utf-8;' 
                });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ope_reviews_comprehensive_with_quality_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                // Successfully exported reviews to CSV
                
            } catch (error) {
                // Track error analytics
                analyticsData.performanceMetrics.totalRequests++;
                saveAnalyticsData();
                
                alert('Error exporting comprehensive reviews. Please try again.');
            }
        }

        /**
         * Search songs by artist name or song title
         * Supports multi-term search with optimized performance
         */
        function searchSongs() {
            const searchTerm = document.getElementById('song-search').value.toLowerCase().trim();
            const songEntries = document.querySelectorAll('.song-entry[data-artist]');
            
            // Track search for analytics (only if there's a search term)
            if (searchTerm) {
                analyticsData.searches.push({
                    term: searchTerm,
                    timestamp: new Date().toISOString(),
                    results: 0 // Will be updated below
                });
            }
            
            // Early return for empty search
            if (!searchTerm) {
                songEntries.forEach(entry => entry.style.display = 'block');
                hideNoResultsMessage();
                return;
            }
            
            // Split search into individual terms and filter out empty ones
            const searchTerms = searchTerm.split(/\s+/).filter(term => term.length > 0);
            let visibleCount = 0;
            
            songEntries.forEach(entry => {
                const artistText = entry.getAttribute('data-artist');
                const titleText = entry.querySelector('.song-title').textContent.toLowerCase();
                const combinedText = `${artistText} ${titleText}`;
                
                // Check if ALL search terms appear in the combined text
                const shouldShow = searchTerms.every(term => combinedText.includes(term));
                
                entry.style.display = shouldShow ? 'block' : 'none';
                if (shouldShow) visibleCount++;
            });
            
            // Update search results count in analytics
            if (analyticsData.searches.length > 0) {
                analyticsData.searches[analyticsData.searches.length - 1].results = visibleCount;
            }
            
            // Save analytics data
            saveAnalyticsData();
            
            // Show/hide "no results" message
            if (visibleCount === 0) {
                showNoResultsMessage();
            } else {
                hideNoResultsMessage();
            }
        }
        
        /**
         * Show the "no results" message
         */
        function showNoResultsMessage() {
            let noResultsMsg = document.getElementById('no-results-msg');
            if (!noResultsMsg) {
                noResultsMsg = document.createElement('p');
                noResultsMsg.id = 'no-results-msg';
                noResultsMsg.className = 'no-results';
                noResultsMsg.textContent = 'No results, sad.';
                
                const searchSection = document.querySelector('.search-section');
                if (searchSection) {
                    searchSection.appendChild(noResultsMsg);
                }
            }
            noResultsMsg.style.display = 'block';
        }
        
        /**
         * Hide the "no results" message
         */
        function hideNoResultsMessage() {
            const noResultsMsg = document.getElementById('no-results-msg');
            if (noResultsMsg) {
                noResultsMsg.style.display = 'none';
            }
        }

        // Show free page by default
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved analytics data
            loadAnalyticsData();
            
            // Check if there's a hash in the URL for direct navigation
            handleHashNavigation();
            
            // Show default page
            showContent('free');

            // Fetch data from API on load
            fetchDataFromAPI();
        });

        // Function to share a song by copying its direct link to clipboard
        // Creates a unique URL with hash navigation for each song
        function shareSong(songId, songTitle) {
            const currentUrl = window.location.href.split('#')[0];
            const shareUrl = `${currentUrl}#${songId}`;
            
            // Simply copy the direct link to clipboard
            copyToClipboard(songId, songTitle, shareUrl);
        }
        

        
        // Function to copy link to clipboard
        function copyToClipboard(songId, songTitle, shareUrl) {
            const doSuccessUI = () => {
                // Show success message
                const shareBtn = document.querySelector(`#${songId} .share-btn`);
                
                if (shareBtn) {
                    const originalText = shareBtn.textContent;
                    shareBtn.textContent = '‚úÖ Link Copied!';
                    shareBtn.classList.add('copied');
                    
                    setTimeout(() => {
                        shareBtn.textContent = originalText;
                        shareBtn.classList.remove('copied');
                    }, 2000);
                }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl).then(doSuccessUI).catch(() => {
                    // Fallback below
                    try {
                        const ta = document.createElement('textarea');
                        ta.value = shareUrl;
                        ta.setAttribute('readonly', '');
                        ta.style.position = 'absolute';
                        ta.style.left = '-9999px';
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                        doSuccessUI();
                    } catch (err2) {
                        alert('Link: ' + shareUrl);
                    }
                });
            } else {
                // Fallback for insecure contexts
                try {
                    const ta = document.createElement('textarea');
                    ta.value = shareUrl;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'absolute';
                    ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    doSuccessUI();
                } catch (err3) {
                    alert('Link: ' + shareUrl);
                }
            }
        }
        




        // Function to handle hash navigation
        function handleHashNavigation() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                // All reviews go to the songs tab
                showContent('free');
                
                // Wait for API data to load, then scroll to element
                const waitForElement = () => {
                    const targetElement = document.getElementById(hash);
                    if (targetElement) {
                        // Scroll to element
                        targetElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                        
                        // Add a subtle highlight effect
                        targetElement.style.boxShadow = '0 0 20px rgba(0,123,255,0.3)';
                        setTimeout(() => {
                            targetElement.style.boxShadow = '';
                        }, 2000);
                    } else if (reviewsData.length > 0) {
                        // Element should exist now, try again
                        setTimeout(waitForElement, 100);
                    } else {
                        // Still loading, wait longer
                        setTimeout(waitForElement, 500);
                    }
                };
                
                waitForElement();
            }
        }

        // Listen for hash changes
        window.addEventListener('hashchange', handleHashNavigation);

        // Modal functions
        function openDataQualityModal() {
            const modal = document.getElementById('data-quality-modal');
            const modalBody = document.getElementById('modal-body');
            
            // Generate and populate modal content
            modalBody.innerHTML = generateDataQualityDashboard();
            
            // Show modal
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
            
            // Focus management
            const closeBtn = modal.querySelector('.modal-close');
            closeBtn.focus();
        }

        function closeDataQualityModal() {
            const modal = document.getElementById('data-quality-modal');
            modal.style.display = 'none';
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Close modal when clicking outside
        document.getElementById('data-quality-modal').addEventListener('click', (e) => {
            if (e.target.id === 'data-quality-modal') {
                closeDataQualityModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('data-quality-modal');
                if (modal.style.display === 'flex') {
                    closeDataQualityModal();
                }
            }
        });

        // Back to top functionality
        const backToTopBtn = document.getElementById('back-to-top');
        
        // Show/hide button based on scroll position
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopBtn.classList.add('show');
            } else {
                backToTopBtn.classList.remove('show');
            }
        });
        
        // Smooth scroll to top when clicked
        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        
        // Keyboard navigation for tabs
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                const tabs = document.querySelectorAll('.nav a[role="tab"]');
                const currentTab = document.querySelector('.nav a[aria-selected="true"]');
                const currentIndex = Array.from(tabs).indexOf(currentTab);
                
                let nextIndex;
                if (e.key === 'ArrowRight') {
                    nextIndex = (currentIndex + 1) % tabs.length;
                } else {
                    nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                }
                
                const nextTab = tabs[nextIndex];
                const page = nextTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                showContent(page);
                nextTab.focus();
                e.preventDefault();
            }
        });
    </script>

                                                                                                                                                        <!-- Footer -->
<footer class="footer" role="contentinfo">
        
        <div class="footer-content">
            <div class="last-updated">
                <strong>Last updated:</strong> <span id="last-updated-date">Loading...</span> (Los Angeles, CA PST Time)
            </div>
            
            <div class="support-info">
                <strong>Best ways to support:</strong> Bookmark this page, subscribe to the newsletter and podcast, tell all your friends
            </div>
            
            <div class="contact-info">
                <strong>Don't like my reviews?</strong> Email me at bradywgerber at gmail dot com to tell me why I'm wrong, or hate-click my <a href="https://bradygerber.com/" target="_blank" rel="noopener" class="api-link">website</a>
            </div>
            
            <div class="analytics-info">
                <strong>For all my data nerds:</strong> Check out <a href="https://ope-music.netlify.app/api/reviews" target="_blank" class="api-link">OPE!'s public API</a> and <a href="#" onclick="openDataQualityModal(); return false;" class="analytics-link">download OPE!'s review data as a CSV file</a> 
            </div>
            
            <div class="footer-bottom">
                <img src="images/author.png" alt="Brady Gerber" class="author-image">
                <span class="copyright">&copy; 2025 OPE!. All rights reserved.</span>
            </div>
        </div>
    </footer>
</body>
</html>
