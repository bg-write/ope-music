<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPE! - Music Reviews by Brady Gerber</title>
    <meta name="description" content="Music sucks.">
    <meta name="keywords" content="music discovery, song of the week, music recommendations, indie music, new music">
    <meta name="author" content="Brady Gerber">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="OPE! - Music Reviews by Brady Gerber">
    <meta property="og:description" content="Music sucks.">
    <meta property="og:type" content="website">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OPE! - Music Reviews by Brady Gerber">
    <meta name="twitter:description" content="Music sucks.">
    
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
</head>
<body>
    <!-- Skip Navigation Link for Screen Readers -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Header Section with logo and tagline -->
    <!-- Contains the main title, subtitle, and animated logo image -->
    <header class="header-content" role="banner">
        <div class="header-text">
            <h1>OPE!</h1>
            <p>Music reviews by Brady Gerber</p>
            <p>Fueled by corn and spite</p>
        </div>
        <div class="header-image">
            <img src="images/logo.png" alt="OPE! Logo - Animated music note icon" class="logo">
        </div>
    </header>

    <!-- Navigation tabs for switching between different content sections -->
    <!-- Each tab loads content dynamically without page refresh -->
    <nav class="nav" role="navigation" aria-label="Main navigation">
        <a href="#" onclick="showContent('free')" id="free-link" role="tab" aria-selected="true" aria-controls="content-container">Songs</a>
        <a href="#" onclick="showContent('newsletter')" id="newsletter-link" role="tab" aria-selected="false" aria-controls="content-container">Newsletter</a>
        <a href="#" onclick="showContent('podcast')" id="podcast-link" role="tab" aria-selected="false" aria-controls="content-container">Podcast</a>
        <!-- <a href="#" onclick="showContent('email')" id="email-link" role="tab" aria-selected="false" aria-controls="content-container">Email</a> -->
        <!-- <a href="#" onclick="showContent('albums')" id="albums-link" role="tab" aria-selected="false" aria-controls="content-container">Album Reviews</a> -->
        <!-- <a href="#" onclick="showContent('members')" id="members-link" role="tab" aria-selected="false" aria-controls="content-container">Exclusive Member Content</a> -->
    </nav>

    <!-- Content Container - dynamically populated by JavaScript -->
    <!-- Content is loaded from the 'content' object below, which gets updated by build.js -->
    <main id="main-content" role="main" aria-live="polite" aria-label="Page content">
        <div id="content-container">
            <!-- Content will be loaded here dynamically -->
            <p>Content will be loaded from Markdown files...</p>
        </div>
    </main>

    <!-- Floating Back to Top Button -->
    <button id="back-to-top" class="back-to-top-btn" aria-label="Back to top of page" title="Back to top">
        ‚Üë
    </button>

    <script>
        // API Configuration
        const API_BASE = 'https://ope-music.netlify.app/api';
        
        // Global data storage
        let reviewsData = [];
        
        // Analytics tracking
        let analyticsData = {
            pageViews: {},
            searches: [],
            reviewClicks: [],
            sessionStart: new Date().toISOString()
        };
        
        // Content data - Now dynamically populated from API
        let content = {
            free: { title: "Songs", html: '<div class="section"><p>Loading reviews...</p></div>' },
            newsletter: { title: "Newsletter", html: `<div class="section">
        <p>A link to the week's reviews every Friday, along with other "fun" links and "musings" on "life": <a href="https://bradygerber.com/newsletter/" target="_blank" rel="noopener">https://bradygerber.com/newsletter/</a></p>
    </div>` },
            podcast: { title: "Podcast", html: `<div class="section">
        <p>My reviews, but easier to understand: <a href="https://bradygerber.com/podcast-and-youtube/" target="_blank" rel="noopener">https://bradygerber.com/podcast-and-youtube/</a></p>
    </div>` },
            members: { title: "All Weekly Picks", html: '<div class="section"><p>Loading all content...</p></div>' }
        };

        /**
         * Convert numeric rating to 4-star display using Roger Ebert's method
         * @param {string} rating - Rating string (e.g., "3.5/4")
         * @returns {string} HTML string with 4 stars
         */
        function generateStarRating(rating) {
            // Parse the rating (e.g., "3.5/4" -> 3.5 out of 4)
            const ratingMatch = rating.match(/(\d+(?:\.\d+)?)\/(\d+)/);
            if (!ratingMatch) return rating; // Fallback to original if can't parse
            
            const score = parseFloat(ratingMatch[1]);
            const maxScore = parseInt(ratingMatch[2]);
            
            // Convert to 4-star scale
            const fourStarScore = (score / maxScore) * 4;
            
            // Create star rating container with Roger Ebert's approach
            const starsHTML = `
                <div class="star-box" title="${rating}">
                    <div class="stars-empty">‚òÜ‚òÜ‚òÜ‚òÜ</div>
                    <div class="stars-filled" style="width: ${(fourStarScore / 4) * 100}%">‚òÖ‚òÖ‚òÖ‚òÖ</div>
                </div>
            `;
            
            return starsHTML;
        }

        /**
         * Generate HTML for a song review entry
         * @param {Object} song - Song review data from API
         * @param {string} song.song_title - Title of the song
         * @param {string} song.song_artist - Name of the artist
         * @param {string} song.review_score - Rating (e.g., "3.5/4")
         * @param {string} song.review_date - Date of the review
         * @param {string} song.review_text - Review description
         * @param {string} song.song_url - URL to listen to the song
         * @param {string} song.review_id - Unique identifier for the review
         * @returns {string} HTML string for the song entry
         */
        function generateSongHTML(song) {
            return `
            <div class="song-entry" id="${song.review_id}" data-artist="${song.song_artist.toLowerCase()} ${song.song_title.toLowerCase()}">
                <h3 class="song-title">${song.song_artist} - "${song.song_title}"</h3>
                <div class="song-rating">${generateStarRating(song.review_score)}</div>
                <p class="song-date">${song.review_date}</p>
                <p class="song-description">${song.review_text}</p>
                <div class="song-links">
                    <a href="${song.song_url}" target="_blank" rel="noopener">Listen</a>
                </div>
            </div>`;
        }

        /**
         * Generate HTML for a link entry (future feature)
         * @param {Object} link - Link data from API
         * @param {string} link.title - Title of the link
         * @param {string} link.date - Date of the link
         * @param {string} link.description - Description of the link
         * @param {string} link.url - URL to the link
         * @returns {string} HTML string for the link entry
         */


        /**
         * Update the content object with data from the API
         * Generates HTML for songs and links, updates footer date
         */
        function updateContentFromAPI() {
            // Update Songs tab (free)
            if (reviewsData.length > 0) {
                const songsHTML = `
                <div class="section">
                    <div class="search-section">
                        <input type="text" id="song-search" placeholder="Search for artist or song..." onkeyup="searchSongs()">
                        <p class="search-help">Type a song title (e.g., "Like a Rolling Stone") or artist name to search</p>
                    </div>
                    ${reviewsData.map(song => generateSongHTML(song)).join('')}
                </div>`;
                content.free.html = songsHTML;
            }

            // Update All Weekly Picks tab (members)
            if (reviewsData.length > 0) {
                const membersHTML = `
                <div class="section">
                    <div class="search-section">
                        <input type="text" id="song-search" placeholder="Search for artist or song..." onkeyup="searchSongs()">
                        <p class="search-help">Type a song title (e.g., "Like a Rolling Stone") or artist name to search</p>
                        ${reviewsData.map(song => generateSongHTML(song)).join('')}
                    </div>`;
                content.members.html = membersHTML;
            }

            // Update footer date with most recent review date
            if (reviewsData.length > 0) {
                const mostRecentReview = reviewsData[0]; // First review is most recent
                const lastUpdatedSpan = document.getElementById('last-updated-date');
                if (lastUpdatedSpan) {
                    lastUpdatedSpan.textContent = mostRecentReview.review_date;
                }
            }
            
            // Add subtle animation to new content
            setTimeout(() => {
                const songEntries = document.querySelectorAll('.song-entry');
                songEntries.forEach((entry, index) => {
                    entry.style.opacity = '0';
                    entry.style.transform = 'translateY(20px)';
                    entry.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                    
                    setTimeout(() => {
                        entry.style.opacity = '1';
                        entry.style.transform = 'translateY(0)';
                    }, index * 50); // Stagger the animation
                });
            }, 100);
        }

        /**
         * Fetch review data from the API and update the UI
         * Handles loading states, error handling, and content updates
         * @returns {Promise<void>}
         */
        async function fetchDataFromAPI() {
            try {
                // Show loading state
                content.free.html = '<div class="section"><p>üîÑ Loading reviews from API...</p></div>';
                content.members.html = '<div class="section"><p>üîÑ Loading all content from API...</p></div>';
                
                // Refresh current tab to show loading
                const currentTab = document.querySelector('.nav a[aria-selected="true"]');
                if (currentTab) {
                    const currentPage = currentTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                    showContent(currentPage);
                }

                // Fetch reviews
                const reviewsResponse = await fetch(`${API_BASE}/reviews`);
                if (!reviewsResponse.ok) {
                    throw new Error(`HTTP ${reviewsResponse.status}: ${reviewsResponse.statusText}`);
                }
                
                const reviewsResult = await reviewsResponse.json();
                reviewsData = reviewsResult.reviews || [];



                // Update content with API data
                updateContentFromAPI();

                // If we're on a tab that needs to refresh, refresh it
                if (currentTab) {
                    const currentPage = currentTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                    showContent(currentPage);
                }

                // API data loaded successfully
            } catch (error) {
                console.error('‚ùå Error fetching API data:', error);
                // Create error HTML with retry button
                const errorHTML = `<div class="section">
                    <p>‚ùå Error loading reviews: ${error.message}</p>
                    <p><button onclick="fetchDataFromAPI()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">üîÑ Retry</button></p>
                </div>`;
                
                content.free.html = errorHTML;
                content.members.html = errorHTML;
                
                // Refresh current tab to show error
                const currentTab = document.querySelector('.nav a[aria-selected="true"]');
                if (currentTab) {
                    const currentPage = currentTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                    showContent(currentPage);
                }
            }
        }

        // Function to show content
        function showContent(page) {
            const container = document.getElementById('content-container');
            const freeLink = document.getElementById('free-link');
            const newsletterLink = document.getElementById('newsletter-link');
            const podcastLink = document.getElementById('podcast-link');
            
            // Track page view for analytics
            if (!analyticsData.pageViews[page]) {
                analyticsData.pageViews[page] = 0;
            }
            analyticsData.pageViews[page]++;
            
            // Save analytics data
            saveAnalyticsData();
            
            // Update content
            container.innerHTML = content[page].html;
            
            // Update navigation styling and ARIA states
            freeLink.classList.remove('active');
            freeLink.setAttribute('aria-selected', 'false');
            newsletterLink.classList.remove('active');
            newsletterLink.setAttribute('aria-selected', 'false');
            podcastLink.classList.remove('active');
            podcastLink.setAttribute('aria-selected', 'false');
            
            if (page === 'free') {
                freeLink.classList.add('active');
                freeLink.setAttribute('aria-selected', 'true');
            } else if (page === 'newsletter') {
                newsletterLink.classList.add('active');
                newsletterLink.setAttribute('aria-selected', 'true');
            } else if (page === 'podcast') {
                podcastLink.classList.add('active');
                podcastLink.setAttribute('aria-selected', 'true');
            }
            
            // Update page title
            document.title = `OPE! - ${content[page].title}`;
            
            // Announce page change to screen readers
            announcePageChange(content[page].title);
        }
        
        // Function to announce page changes to screen readers
        function announcePageChange(pageTitle) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = `Switched to ${pageTitle} page`;
            
            document.body.appendChild(announcement);
            
            // Remove after announcement
            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }
        
        /**
         * Save analytics data to localStorage
         */
        function saveAnalyticsData() {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem('opeAnalytics', JSON.stringify(analyticsData));
            }
        }
        
        /**
         * Load analytics data from localStorage
         */
        function loadAnalyticsData() {
            if (typeof localStorage !== 'undefined') {
                const saved = localStorage.getItem('opeAnalytics');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        analyticsData = { ...analyticsData, ...parsed };
                    } catch (e) {
                        console.warn('Could not parse saved analytics data');
                    }
                }
            }
        }
        
        /**
         * Export analytics data as CSV for SQL practice
         */
        function exportAnalyticsCSV() {
            const csvData = [];
            
            // Page views data
            Object.entries(analyticsData.pageViews).forEach(([page, count]) => {
                csvData.push(`page_view,${page},${count},${new Date().toISOString()}`);
            });
            
            // Search data
            analyticsData.searches.forEach(search => {
                csvData.push(`search,${search.term},${search.results},${search.timestamp}`);
            });
            
            // Review clicks data
            analyticsData.reviewClicks.forEach(click => {
                csvData.push(`review_click,${click.reviewId},${click.reviewTitle},${click.timestamp}`);
            });
            
            // API endpoints information
            csvData.push(`api_endpoint,/reviews,all_reviews,${new Date().toISOString()}`);
            
            const csv = `event_type,value,count,timestamp\n${csvData.join('\n')}`;
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ope_analytics_${new Date().toISOString()}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        /**
         * Export review metadata as CSV for data analysis
         */
        async function exportReviewsCSV() {
            try {
                // Fetch the latest review data from your API
                const response = await fetch('https://ope-music.netlify.app/.netlify/functions/reviews');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const reviews = data.reviews || [];
                
                if (reviews.length === 0) {
                    alert('No reviews found to export');
                    return;
                }
                
                // Create CSV with review metadata
                const csvData = [];
                
                // Add header row
                csvData.push('song_title,song_artist,review_date,review_score,review_text,song_url,review_id');
                
                // Add each review as a row
                reviews.forEach(review => {
                    // Clean and escape the review text for CSV
                    const cleanText = review.review_text.replace(/"/g, '""').replace(/\n/g, ' ');
                    const cleanTitle = review.song_title.replace(/"/g, '""');
                    const cleanArtist = review.song_artist.replace(/"/g, '""');
                    
                    // Convert review score from fraction to decimal (e.g., "1/4" -> "1.0")
                    let reviewScore = review.review_score;
                    if (reviewScore && reviewScore.includes('/')) {
                        const [numerator, denominator] = reviewScore.split('/');
                        const decimalScore = (parseFloat(numerator) / parseFloat(denominator)) * 4;
                        reviewScore = decimalScore.toFixed(1); // Keep 1 decimal place
                    }
                    
                    csvData.push(`"${cleanTitle}","${cleanArtist}","${review.review_date}","${reviewScore}","${cleanText}","${review.song_url}","${review.review_id}"`);
                });
                
                            // Create and download CSV with proper headers
            const csv = csvData.join('\n');
            const blob = new Blob(['\ufeff' + csv], { 
                type: 'text/csv;charset=utf-8;' 
            });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ope_reviews_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
                
                // Successfully exported reviews to CSV
                
            } catch (error) {
                console.error('‚ùå Error exporting reviews:', error);
                alert('Error exporting reviews. Please try again.');
            }
        }

        /**
         * Search songs by artist name or song title
         * Supports multi-term search with optimized performance
         */
        function searchSongs() {
            const searchTerm = document.getElementById('song-search').value.toLowerCase().trim();
            const songEntries = document.querySelectorAll('.song-entry[data-artist]');
            
            // Track search for analytics (only if there's a search term)
            if (searchTerm) {
                analyticsData.searches.push({
                    term: searchTerm,
                    timestamp: new Date().toISOString(),
                    results: 0 // Will be updated below
                });
            }
            
            // Early return for empty search
            if (!searchTerm) {
                songEntries.forEach(entry => entry.style.display = 'block');
                hideNoResultsMessage();
                return;
            }
            
            // Split search into individual terms and filter out empty ones
            const searchTerms = searchTerm.split(/\s+/).filter(term => term.length > 0);
            let visibleCount = 0;
            
            songEntries.forEach(entry => {
                const artistText = entry.getAttribute('data-artist');
                const titleText = entry.querySelector('.song-title').textContent.toLowerCase();
                const combinedText = `${artistText} ${titleText}`;
                
                // Check if ALL search terms appear in the combined text
                const shouldShow = searchTerms.every(term => combinedText.includes(term));
                
                entry.style.display = shouldShow ? 'block' : 'none';
                if (shouldShow) visibleCount++;
            });
            
            // Update search results count in analytics
            if (analyticsData.searches.length > 0) {
                analyticsData.searches[analyticsData.searches.length - 1].results = visibleCount;
            }
            
            // Save analytics data
            saveAnalyticsData();
            
            // Show/hide "no results" message
            if (visibleCount === 0) {
                showNoResultsMessage();
            } else {
                hideNoResultsMessage();
            }
        }
        
        /**
         * Show the "no results" message
         */
        function showNoResultsMessage() {
            let noResultsMsg = document.getElementById('no-results-msg');
            if (!noResultsMsg) {
                noResultsMsg = document.createElement('p');
                noResultsMsg.id = 'no-results-msg';
                noResultsMsg.className = 'no-results';
                noResultsMsg.textContent = 'No results, sad.';
                
                const searchSection = document.querySelector('.search-section');
                if (searchSection) {
                    searchSection.appendChild(noResultsMsg);
                }
            }
            noResultsMsg.style.display = 'block';
        }
        
        /**
         * Hide the "no results" message
         */
        function hideNoResultsMessage() {
            const noResultsMsg = document.getElementById('no-results-msg');
            if (noResultsMsg) {
                noResultsMsg.style.display = 'none';
            }
        }

        // Show free page by default
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved analytics data
            loadAnalyticsData();
            
            // Check if there's a hash in the URL for direct navigation
            handleHashNavigation();
            
            // Show default page
            showContent('free');

            // Fetch data from API on load
            fetchDataFromAPI();
        });

        // Function to share a song by copying its direct link to clipboard
        // Creates a unique URL with hash navigation for each song
        function shareSong(songId, songTitle) {
            const currentUrl = window.location.href.split('#')[0];
            const shareUrl = `${currentUrl}#${songId}`;
            
            // Simply copy the direct link to clipboard
            copyToClipboard(songId, songTitle, shareUrl);
        }
        

        
        // Function to copy link to clipboard
        function copyToClipboard(songId, songTitle, shareUrl) {
            const doSuccessUI = () => {
                // Show success message
                const shareBtn = document.querySelector(`#${songId} .share-btn`);
                
                if (shareBtn) {
                    const originalText = shareBtn.textContent;
                    shareBtn.textContent = '‚úÖ Link Copied!';
                    shareBtn.classList.add('copied');
                    
                    setTimeout(() => {
                        shareBtn.textContent = originalText;
                        shareBtn.classList.remove('copied');
                    }, 2000);
                }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl).then(doSuccessUI).catch(() => {
                    // Fallback below
                    try {
                        const ta = document.createElement('textarea');
                        ta.value = shareUrl;
                        ta.setAttribute('readonly', '');
                        ta.style.position = 'absolute';
                        ta.style.left = '-9999px';
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                        doSuccessUI();
                    } catch (err2) {
                        alert('Link: ' + shareUrl);
                    }
                });
            } else {
                // Fallback for insecure contexts
                try {
                    const ta = document.createElement('textarea');
                    ta.value = shareUrl;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'absolute';
                    ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    doSuccessUI();
                } catch (err3) {
                    alert('Link: ' + shareUrl);
                }
            }
        }
        




        // Function to handle hash navigation
        function handleHashNavigation() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                // All reviews go to the songs tab
                showContent('free');
                
                // Wait for API data to load, then scroll to element
                const waitForElement = () => {
                    const targetElement = document.getElementById(hash);
                    if (targetElement) {
                        // Scroll to element
                        targetElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                        
                        // Add a subtle highlight effect
                        targetElement.style.boxShadow = '0 0 20px rgba(0,123,255,0.3)';
                        setTimeout(() => {
                            targetElement.style.boxShadow = '';
                        }, 2000);
                    } else if (reviewsData.length > 0) {
                        // Element should exist now, try again
                        setTimeout(waitForElement, 100);
                    } else {
                        // Still loading, wait longer
                        setTimeout(waitForElement, 500);
                    }
                };
                
                waitForElement();
            }
        }

        // Listen for hash changes
        window.addEventListener('hashchange', handleHashNavigation);

        // Back to top functionality
        const backToTopBtn = document.getElementById('back-to-top');
        
        // Show/hide button based on scroll position
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopBtn.classList.add('show');
            } else {
                backToTopBtn.classList.remove('show');
            }
        });
        
        // Smooth scroll to top when clicked
        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        
        // Keyboard navigation for tabs
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                const tabs = document.querySelectorAll('.nav a[role="tab"]');
                const currentTab = document.querySelector('.nav a[aria-selected="true"]');
                const currentIndex = Array.from(tabs).indexOf(currentTab);
                
                let nextIndex;
                if (e.key === 'ArrowRight') {
                    nextIndex = (currentIndex + 1) % tabs.length;
                } else {
                    nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                }
                
                const nextTab = tabs[nextIndex];
                const page = nextTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                showContent(page);
                nextTab.focus();
                e.preventDefault();
            }
        });
    </script>

                                                                                                                                                        <!-- Footer -->
<footer class="footer" role="contentinfo">
        
        <div class="footer-content">
            <div class="last-updated">
                <strong>Last updated:</strong> <span id="last-updated-date">Loading...</span> (Los Angeles, CA PST Time)
            </div>
            
            <div class="support-info">
                <strong>Best ways to support:</strong> Bookmark this page, subscribe to the newsletter and podcast, tell all your friends
            </div>
            
            <div class="contact-info">
                <strong>Don't like my reviews?</strong> Email me at bradywgerber at gmail dot com to tell me why I'm wrong, or hate-click my <a href="https://bradygerber.com/" target="_blank" rel="noopener" class="api-link">website</a>
            </div>
            
            <div class="analytics-info">
                <strong>For all my data nerds:</strong> Check out <a href="https://ope-music.netlify.app/api/reviews" target="_blank" class="api-link">OPE!'s public API</a> and <a href="#" onclick="exportReviewsCSV(); return false;" class="analytics-link">download OPE!'s review data as a CSV file</a> üìä 
            </div>
            
            <div class="footer-bottom">
                <img src="images/author.png" alt="Brady Gerber" class="author-image">
                <span class="copyright">&copy; 2025 OPE!. All rights reserved.</span>
            </div>
        </div>
    </footer>
</body>
</html>
