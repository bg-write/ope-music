<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPE! - Music Reviews by Brady Gerber</title>
    <meta name="description" content="Music sucks.">
    <meta name="keywords" content="music discovery, song of the week, music recommendations, indie music, new music">
    <meta name="author" content="Brady Gerber">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="OPE! - Music Reviews by Brady Gerber">
    <meta property="og:description" content="Music sucks.">
    <meta property="og:type" content="website">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="OPE! - Music Reviews by Brady Gerber">
    <meta name="twitter:description" content="Music sucks.">
    
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
</head>
<body>
    <!-- Skip Navigation Link for Screen Readers -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Header Section with logo and tagline -->
    <!-- Contains the main title, subtitle, and animated logo image -->
    <header class="header-content" role="banner">
        <div class="header-text">
            <h1>OPE!</h1>
            <p>Music reviews by Brady Gerber</p>
            <p>Fueled by corn and spite</p>
        </div>
        <div class="header-image">
            <img src="images/logo.png" alt="OPE! Logo - Animated music note icon" class="logo">
        </div>
    </header>

    <!-- Navigation tabs for switching between different content sections -->
    <!-- Each tab loads content dynamically without page refresh -->
    <nav class="nav" role="navigation" aria-label="Main navigation">
        <a href="#" onclick="showContent('free')" id="free-link" role="tab" aria-selected="true" aria-controls="content-container">Song Reviews</a>
        <a href="#" onclick="showContent('billboard')" id="billboard-link" role="tab" aria-selected="false" aria-controls="content-container">Billboard Watch</a>
        <a href="#" onclick="showContent('newsletter-podcast')" id="newsletter-podcast-link" role="tab" aria-selected="false" aria-controls="content-container">Newsletter & Podcast</a>
        <!-- <a href="#" onclick="showContent('email')" id="email-link" role="tab" aria-selected="false" aria-controls="content-container">Email</a> -->
        <!-- <a href="#" onclick="showContent('albums')" id="albums-link" role="tab" aria-selected="false" aria-controls="content-container">Album Reviews</a> -->
        <!-- <a href="#" onclick="showContent('members')" id="members-link" role="tab" aria-selected="false" aria-controls="content-container">Exclusive Member Content</a> -->
    </nav>

    <!-- Content Container - dynamically populated by JavaScript -->
    <!-- Content is loaded from the 'content' object below, which gets updated by build.js -->
    <main id="main-content" role="main" aria-live="polite" aria-label="Page content">
        <div id="content-container">
            <!-- Content will be loaded here dynamically -->
            <p>Content will be loaded from Markdown files...</p>
        </div>
    </main>

    <!-- Data Quality Modal -->
    <div id="data-quality-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📊 Data Quality Dashboard</h2>
                <button class="modal-close" onclick="closeDataQualityModal()" aria-label="Close modal">×</button>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Modal content will be populated here -->
            </div>
        </div>
    </div>

    <!-- Floating Back to Top Button -->
    <button id="back-to-top" class="back-to-top-btn" aria-label="Back to top of page" title="Back to top">
        ↑
    </button>

    <script>
        // API Configuration
        const API_BASE = 'https://ope-music.netlify.app/api';
        
        // Global data storage
        let reviewsData = [];
        
        // Data validation utilities
        const DataValidator = {
            sanitizeText: (text) => {
                if (typeof text !== 'string') return '';
                return text.replace(/[<>]/g, '').trim();
            },
            
            validateReview: (review) => {
                const errors = [];
                
                // Check required song metadata fields
                if (!review.song_title || review.song_title.trim().length === 0) {
                    errors.push('Missing song title');
                }
                if (!review.song_artist || review.song_artist.trim().length === 0) {
                    errors.push('Missing artist name');
                }
                
                // Check review score - now accepts decimal format (1.0, 0.5, etc.)
                if (!review.review_score) {
                    errors.push('Missing review score');
                } else {
                    // Accept both decimal format (1.0, 0.5) and fraction format (1/4, 0.5/4)
                    const scorePatterns = [
                        /^\d+(\.\d+)?$/, // Decimal format: 1.0, 0.5, 4.0
                        /^\d+(\.\d+)?\/\d+$/ // Fraction format: 1/4, 0.5/4
                    ];
                    
                    const isValidScore = scorePatterns.some(pattern => pattern.test(review.review_score.toString()));
                    if (!isValidScore) {
                        errors.push(`Invalid review score format: "${review.review_score}"`);
                    }
                }
                
                // Check review text
                if (!review.review_text || review.review_text.trim().length === 0) {
                    errors.push('Missing review text');
                }
                
                // Check review date - accept various formats
                if (!review.review_date) {
                    errors.push('Missing review date');
                } else {
                    // Accept formats like: "August 20, 2025", "2025-08-20", "8/20/2025"
                    const dateFormats = [
                        /^[A-Za-z]+ \d{1,2}, \d{4}$/, // "August 20, 2025"
                        /^\d{4}-\d{2}-\d{2}$/, // "2025-08-20"
                        /^\d{1,2}\/\d{1,2}\/\d{4}$/ // "8/20/2025"
                    ];
                    
                    const isValidDate = dateFormats.some(format => format.test(review.review_date));
                    if (!isValidDate) {
                        errors.push(`Invalid date format: "${review.review_date}"`);
                    }
                }
                
                return { isValid: errors.length === 0, errors };
            },
            
            sanitizeReview: (review) => {
                return {
                    ...review,
                    song_title: DataValidator.sanitizeText(review.song_title),
                    song_artist: DataValidator.sanitizeText(review.song_artist),
                    review_text: DataValidator.sanitizeText(review.review_text),
                    song_audio_url: review.song_audio_url || '',
                    review_id: review.review_id || ''
                };
            }
        };
        
        // Analytics tracking
        let analyticsData = {
            pageViews: {},
            searches: [],
            reviewClicks: [],
            apiErrors: [],
            dataQualityIssues: [],
            performanceMetrics: {
                apiResponseTimes: [],
                errorRates: 0,
                totalRequests: 0
            },
            sessionStart: new Date().toISOString()
        };
        
        // Content data - Now dynamically populated from API
        let content = {
            free: { title: "Songs", html: '<div class="section"><p>Loading reviews...</p></div>' },
            'newsletter-podcast': { title: "Newsletter & Podcast", html: `<div class="section">
        <h2>Newsletter</h2>
        <p>A link to the week's reviews every Friday, along with other "fun" links and "musings" on "life": <a href="https://bradygerber.com/newsletter/" target="_blank" rel="noopener">https://bradygerber.com/newsletter/</a></p>
        
        <h2>Podcast</h2>
        <p>My reviews, but easier to understand: <a href="https://bradygerber.com/podcast-and-youtube/" target="_blank" rel="noopener">https://bradygerber.com/podcast-and-youtube/</a></p>
    </div>` },
            billboard: { title: "Billboard Watch", html: '<div class="section"><p>Loading Billboard Watch...</p></div>' },

        };

        /**
         * Convert numeric rating to 4-star display using Roger Ebert's method
         * @param {string} rating - Rating string (e.g., "3.5/4")
         * @returns {string} HTML string with 4 stars
         */
        function generateStarRating(rating) {
            let score, maxScore;
            
            // Handle decimal format (e.g., 1.0, 0.5, 3.5)
            if (typeof rating === 'number' || (typeof rating === 'string' && !rating.includes('/'))) {
                score = parseFloat(rating);
                maxScore = 4; // Assume 4-point scale for decimal ratings
            } 
            // Handle fraction format (e.g., "3.5/4", "1/4")
            else if (typeof rating === 'string' && rating.includes('/')) {
                const ratingMatch = rating.match(/(\d+(?:\.\d+)?)\/(\d+)/);
                if (!ratingMatch) return rating; // Fallback to original if can't parse
                
                score = parseFloat(ratingMatch[1]);
                maxScore = parseInt(ratingMatch[2]);
            } 
            // Fallback for unexpected formats
            else {
                return rating;
            }
            
            // Convert to 4-star scale
            const fourStarScore = (score / maxScore) * 4;
            
            // Create star rating container with Roger Ebert's approach
            const starsHTML = `
                <div class="star-box" title="${rating}">
                    <div class="stars-empty">☆☆☆☆</div>
                    <div class="stars-filled" style="width: ${(fourStarScore / 4) * 100}%">★★★★</div>
                </div>
            `;
            
            return starsHTML;
        }

        /**
         * Generate HTML for a song review entry
         * @param {Object} song - Song review data from API
         * @param {string} song.song_title - Title of the song
         * @param {string} song.song_artist - Name of the artist
         * @param {string} song.review_score - Rating (e.g., "3.5/4")
         * @param {string} song.review_date - Date of the review
         * @param {string} song.review_text - Review description
         * @param {string} song.song_audio_url - URL to listen to the song
         * @param {string} song.review_id - Unique identifier for the review
         * @returns {string} HTML string for the song entry
         */
        function generateSongHTML(song) {
            return `
            <div class="song-entry" id="${song.review_id}" data-artist="${song.song_artist.toLowerCase()} ${song.song_title.toLowerCase()}">
                <h3 class="song-title">${song.song_artist} - "${song.song_title}"</h3>
                <div class="song-rating">${generateStarRating(song.review_score)}</div>
                <p class="song-date">${song.review_date_display || song.review_date}</p>
                <p class="song-description">${song.review_text}</p>
                <div class="song-links">
                    <a href="${song.song_audio_url}" target="_blank" rel="noopener">Listen</a>
                </div>
            </div>`;
        }

        /**
         * Generate HTML for a link entry (future feature)
         * @param {Object} link - Link data from API
         * @param {string} link.title - Title of the link
         * @param {string} link.date - Date of the link
         * @param {string} link.description - Description of the link
         * @param {string} link.url - URL to the link
         * @returns {string} HTML string for the link entry
         */


        /**
         * Generate data quality dashboard HTML
         * Shows validation statistics and download options
         */
        function generateDataQualityDashboard() {
            if (!reviewsData || reviewsData.length === 0) {
                return '<div class="section"><p>No data available for quality analysis.</p></div>';
            }
            
            // Calculate validation statistics
            const totalReviews = reviewsData.length;
            const validationResults = {
                total: totalReviews,
                valid: 0,
                invalid: 0,
                issues: []
            };
            
            reviewsData.forEach((review, index) => {
                const validation = DataValidator.validateReview(review);
                if (validation.isValid) {
                    validationResults.valid++;
                } else {
                    validationResults.invalid++;
                    validationResults.issues.push({
                        index,
                        errors: validation.errors
                    });
                }
            });
            
            const qualityScore = ((validationResults.valid / validationResults.total) * 100).toFixed(1);
            
            return `
                <div class="section">
                    <h2>📊 Data Quality Dashboard</h2>
                    <p>Monitor the health and integrity of your review data.</p>
                    
                    <div class="data-quality-stats">
                        <div class="stat-card">
                            <h3>Total Reviews</h3>
                            <p class="stat-number">${validationResults.total}</p>
                        </div>
                        <div class="stat-card">
                            <h3>Valid Reviews</h3>
                            <p class="stat-number valid">${validationResults.valid}</p>
                        </div>
                        <div class="stat-card">
                            <h3>Data Quality Score</h3>
                            <p class="stat-number">${qualityScore}%</p>
                        </div>
                    </div>
                    
                    <div class="download-section">
                        <h3>📥 Data Downloads</h3>
                        <div class="download-options">
                            <div class="download-option">
                                                                  <h4>🚀 BigQuery Ready CSV</h4>
                                  <p>Comprehensive data with all metadata fields for analysis</p>
                                <button onclick="exportCleanCSV()" class="download-btn">Download Comprehensive CSV</button>
                            </div>
                            <div class="download-option">
                                <h4>📋 Full Report CSV</h4>
                                <p>Includes data quality metadata and validation status</p>
                                <button onclick="exportReviewsCSV()" class="download-btn">Download Full Report with Quality</button>
                            </div>
                            <div class="download-option">
                                <h4>📈 Analytics Data</h4>
                                <p>User behavior and performance metrics</p>
                                <button class="download-btn coming-soon" disabled>Coming Soon!</button>
                            </div>
                        </div>
                    </div>
                    
                    ${validationResults.issues.length > 0 ? `
                        <div class="data-issues-section">
                            <h3>⚠️ Data Quality Issues</h3>
                            <p>Found ${validationResults.issues.length} reviews with validation issues:</p>
                            <div class="issues-list">
                                ${validationResults.issues.map(issue => `
                                    <div class="issue-item">
                                        <strong>Review ${issue.index + 1}:</strong> ${issue.errors.join(', ')}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : `
                        <div class="data-issues-section">
                            <h3>✅ All Data Validated</h3>
                            <p>Great job! All ${validationResults.total} reviews passed validation checks.</p>
                        </div>
                    `}
                </div>
            `;
        }

        /**
         * Update the content object with data from the API
         * Generates HTML for songs and links, updates footer date
         */
        function updateContentFromAPI() {
            // Update Songs tab (free)
            if (reviewsData.length > 0) {
                const songsHTML = `
                <div class="section">
                    <div class="search-section">
                        <input type="text" id="song-search" placeholder="Search for artist or song..." onkeyup="searchSongs()">
                        <p class="search-help">Type a song title (e.g., "Like a Rolling Stone") or artist name to search</p>
                    </div>
                    ${reviewsData.map(song => generateSongHTML(song)).join('')}
                </div>`;
                content.free.html = songsHTML;
            }



            // Update footer date with most recent review date
            if (reviewsData.length > 0) {
                const mostRecentReview = reviewsData[0]; // First review is most recent
                const lastUpdatedSpan = document.getElementById('last-updated-date');
                if (lastUpdatedSpan) {
                    lastUpdatedSpan.textContent = mostRecentReview.review_date_display || mostRecentReview.review_date;
                }
            }
            
            // Add subtle animation to new content
            setTimeout(() => {
                const songEntries = document.querySelectorAll('.song-entry');
                songEntries.forEach((entry, index) => {
                    entry.style.opacity = '0';
                    entry.style.transform = 'translateY(20px)';
                    entry.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                    
                    setTimeout(() => {
                        entry.style.opacity = '1';
                        entry.style.transform = 'translateY(0)';
                    }, index * 50); // Stagger the animation
                });
            }, 100);
        }

        /**
         * Fetch review data from the API and update the UI
         * Handles loading states, error handling, and content updates
         * @returns {Promise<void>}
         */
        async function fetchDataFromAPI() {
            try {
                // Show loading state
                content.free.html = '<div class="section"><p>🔄 Loading reviews from API...</p></div>';

                
                // Refresh current tab to show loading
                const currentTab = document.querySelector('.nav a[aria-selected="true"]');
                if (currentTab) {
                    const currentPage = currentTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                    showContent(currentPage);
                }

                // Fetch reviews
                const reviewsResponse = await fetch(`${API_BASE}/reviews`);
                if (!reviewsResponse.ok) {
                    throw new Error(`HTTP ${reviewsResponse.status}: ${reviewsResponse.statusText}`);
                }
                
                const reviewsResult = await reviewsResponse.json();
                reviewsData = reviewsResult.reviews || [];
                
                // Validate and sanitize all reviews
                const rawReviews = reviewsResult.reviews || [];
                const validatedReviews = [];
                const dataQualityIssues = [];
                
                rawReviews.forEach((review, index) => {
                    const validation = DataValidator.validateReview(review);
                    if (validation.isValid) {
                        validatedReviews.push(DataValidator.sanitizeReview(review));
                    } else {
                        dataQualityIssues.push({
                            reviewIndex: index,
                            errors: validation.errors,
                            review: review
                        });
                        // Track data quality issues for analytics
                        if (validation.errors.length > 1) {
                            analyticsData.dataQualityIssues.push({
                                reviewIndex: index,
                                errors: validation.errors,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                });
                
                // Store validated data (fallback to raw if all validation fails)
                if (validatedReviews.length > 0) {
                    reviewsData = validatedReviews;
                    // Track successful validation for analytics
                    analyticsData.performanceMetrics.totalRequests++;
                } else {
                    // Track validation failure for analytics
                    analyticsData.errors.push({
                        type: 'validation_failure',
                        message: 'All reviews failed validation',
                        timestamp: new Date().toISOString()
                    });
                    reviewsData = rawReviews;
                }
                
                // Track data quality issues for analytics
                if (dataQualityIssues.length > 0) {
                    analyticsData.dataQualityIssues.push(...dataQualityIssues);
                }



                // Update content with API data
                updateContentFromAPI();

                // If we're on a tab that needs to refresh, refresh it
                if (currentTab) {
                    const currentPage = currentTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                    showContent(currentPage);
                }

                // API data loaded successfully
            } catch (error) {
                // Track error analytics
                analyticsData.apiErrors.push({
                    timestamp: new Date().toISOString(),
                    error: error.message,
                    stack: error.stack
                });
                
                // Show error message in content area
                content.free.html = `<div class="section">
                    <p>❌ Failed to load reviews: ${error.message}</p>
                    <p><button onclick="fetchDataFromAPI()" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">🔄 Retry</button></p>
                </div>`;
                
                // Show the error content
                showContent('free');
            }
        }

        // Function to show content
        function showContent(page) {
            const container = document.getElementById('content-container');
            const freeLink = document.getElementById('free-link');
            const newsletterPodcastLink = document.getElementById('newsletter-podcast-link');
            const billboardLink = document.getElementById('billboard-link');
            
            // Track page view for analytics
            if (!analyticsData.pageViews[page]) {
                analyticsData.pageViews[page] = 0;
            }
            analyticsData.pageViews[page]++;
            
            // Save analytics data
            saveAnalyticsData();
            
            // Update content
            container.innerHTML = content[page].html;
            
            // Update navigation styling and ARIA states
            freeLink.classList.remove('active');
            freeLink.setAttribute('aria-selected', 'false');
            newsletterPodcastLink.classList.remove('active');
            newsletterPodcastLink.setAttribute('aria-selected', 'false');
            billboardLink.classList.remove('active');
            billboardLink.setAttribute('aria-selected', 'false');
            
            if (page === 'free') {
                freeLink.classList.add('active');
                freeLink.setAttribute('aria-selected', 'true');
            } else if (page === 'newsletter-podcast') {
                newsletterPodcastLink.classList.add('active');
                newsletterPodcastLink.setAttribute('aria-selected', 'true');
            } else if (page === 'billboard') {
                billboardLink.classList.add('active');
                billboardLink.setAttribute('aria-selected', 'true');
                // Load Billboard data when tab is selected
                loadBillboardData();
            }
            
            // Update page title
            document.title = `OPE! - ${content[page].title}`;
            
            // Announce page change to screen readers
            announcePageChange(content[page].title);
        }
        
        // Function to announce page changes to screen readers
        function announcePageChange(pageTitle) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = `Switched to ${pageTitle} page`;
            
            document.body.appendChild(announcement);
            
            // Remove after announcement
            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }
        
        /**
         * Save analytics data to localStorage
         */
        function saveAnalyticsData() {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem('opeAnalytics', JSON.stringify(analyticsData));
            }
        }
        
        /**
         * Load analytics data from localStorage
         */
        function loadAnalyticsData() {
            if (typeof localStorage !== 'undefined') {
                try {
                    const saved = localStorage.getItem('opeAnalytics');
                    if (saved) {
                        analyticsData = JSON.parse(saved);
                    }
                } catch (error) {
                    // Reset analytics data if parsing fails
                    analyticsData = getDefaultAnalyticsData();
                }
            }
        }
        
        /**
         * Export analytics data as CSV for SQL practice
         */
        function exportAnalyticsCSV() {
            const csvData = [];
            csvData.push('event_type,value,count,timestamp,details');
            
            // Page views data
            Object.entries(analyticsData.pageViews).forEach(([page, count]) => {
                csvData.push(`page_view,${page},${count},${analyticsData.sessionStart},`);
            });
            
            // Search data
            analyticsData.searches.forEach(search => {
                csvData.push(`search,${search.term},${search.results || 1},${search.timestamp},`);
            });
            
            // Review clicks data
            analyticsData.reviewClicks.forEach(click => {
                csvData.push(`review_click,${click.reviewId || click.songTitle},1,${click.timestamp},`);
            });
            
            // API errors
            analyticsData.apiErrors.forEach(error => {
                csvData.push(`api_error,${error.error},1,${error.timestamp},${error.stack}`);
            });
            
            // Data quality issues
            analyticsData.dataQualityIssues.forEach(issue => {
                csvData.push(`data_quality_issue,review_${issue.reviewIndex},1,${new Date().toISOString()},${issue.errors.join(', ')}`);
            });
            
            // Performance metrics
            if (analyticsData.performanceMetrics.apiResponseTimes.length > 0) {
                const avgResponseTime = analyticsData.performanceMetrics.apiResponseTimes.reduce((a, b) => a + b, 0) / analyticsData.performanceMetrics.apiResponseTimes.length;
                csvData.push(`performance_metric,average_response_time,${avgResponseTime.toFixed(2)},${new Date().toISOString()},ms`);
            }
            
            csvData.push(`performance_metric,error_rate,${analyticsData.performanceMetrics.errorRates},${new Date().toISOString()},percentage`);
            csvData.push(`performance_metric,total_requests,${analyticsData.performanceMetrics.totalRequests},${new Date().toISOString()},percentage`);
            
            const csv = `event_type,value,count,timestamp,details\n${csvData.join('\n')}`;
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ope_enhanced_analytics_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        /**
         * Export clean CSV for BigQuery (no metadata rows)
         */
        async function exportCleanCSV() {
            try {
                const response = await fetch('https://ope-music.netlify.app/.netlify/functions/reviews');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const reviews = data.reviews || [];
                
                if (reviews.length === 0) {
                    alert('No reviews found to export');
                    return;
                }
                
                // Create comprehensive CSV with all metadata fields
                const csvData = [];
                
                // Add header row with all metadata fields
                csvData.push('song_title,song_artist,song_release_date,song_upload_date,song_duration_sec,song_album,song_label,song_genre,song_mood,song_instrumentation,song_language,song_audio_url,review_date,review_score,review_text,review_id');
                
                // Add each review as a row
                reviews.forEach((review, index) => {
                    // Clean and escape all text fields for CSV
                    const cleanText = (review.review_text || '').replace(/"/g, '""').replace(/\n/g, ' ');
                    const cleanTitle = (review.song_title || '').replace(/"/g, '""');
                    const cleanArtist = (review.song_artist || '').replace(/"/g, '""');
                    const cleanAlbum = (review.song_album || '').replace(/"/g, '""');
                    const cleanLabel = (review.song_label || '').replace(/"/g, '""');
                    const cleanGenre = (review.song_genre || '').replace(/"/g, '""');
                    const cleanMood = (review.song_mood || '').replace(/"/g, '""');
                    const cleanInstrumentation = (review.song_instrumentation || '').replace(/"/g, '""');
                    
                    // Convert review score to proper decimal format (1/4 -> 1.0, 0.5/4 -> 0.5)
                    let reviewScore = review.review_score;
                    if (reviewScore && typeof reviewScore === 'string' && reviewScore.includes('/')) {
                        const [numerator, denominator] = reviewScore.split('/');
                        if (denominator === '4') {
                            reviewScore = parseFloat(numerator).toFixed(1);
                        }
                    }
                    
                    csvData.push(`"${cleanTitle}","${cleanArtist}","${review.song_release_date || ''}","${review.song_upload_date || ''}","${review.song_duration_sec || ''}","${cleanAlbum}","${cleanLabel}","${cleanGenre}","${cleanMood}","${cleanInstrumentation}","${review.song_language || ''}","${review.song_audio_url || ''}","${review.review_date || ''}","${reviewScore || ''}","${cleanText}","${review.review_id || ''}"`);
                });
                
                const csv = csvData.join('\n');
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ope_reviews_comprehensive_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                // Track export analytics
                analyticsData.performanceMetrics.totalRequests++;
                saveAnalyticsData();
                
            } catch (error) {
                // Track error analytics
                analyticsData.performanceMetrics.totalRequests++;
                saveAnalyticsData();
                
                alert('Failed to export comprehensive CSV. Please try again.');
            }
        }

        /**
         * Export review metadata as CSV for data analysis
         */
        async function exportReviewsCSV() {
            try {
                // Fetch the latest review data from your API
                const response = await fetch('https://ope-music.netlify.app/.netlify/functions/reviews');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const reviews = data.reviews || [];
                
                if (reviews.length === 0) {
                    alert('No reviews found to export');
                    return;
                }
                
                // Create comprehensive CSV with all metadata fields and data quality
                const csvData = [];
                
                // Add header row with all metadata fields plus data quality
                csvData.push('song_title,song_artist,song_release_date,song_upload_date,song_duration_sec,song_album,song_label,song_genre,song_mood,song_instrumentation,song_language,song_audio_url,review_date,review_score,review_text,review_id,data_quality_status');
                
                // Track validation results
                const validationResults = {
                    total: reviews.length,
                    valid: 0,
                    invalid: 0,
                    issues: []
                };
                
                // Add each review as a row
                reviews.forEach((review, index) => {
                    // Validate review data
                    const validation = DataValidator.validateReview(review);
                    const isValid = validation.isValid;
                    
                    if (isValid) {
                        validationResults.valid++;
                    } else {
                        validationResults.invalid++;
                        validationResults.issues.push({
                            index,
                            errors: validation.errors
                        });
                    }
                    
                    // Clean and escape all text fields for CSV
                    const cleanText = (review.review_text || '').replace(/"/g, '""').replace(/\n/g, ' ');
                    const cleanTitle = (review.song_title || '').replace(/"/g, '""');
                    const cleanArtist = (review.song_artist || '').replace(/"/g, '""');
                    const cleanAlbum = (review.song_album || '').replace(/"/g, '""');
                    const cleanLabel = (review.song_label || '').replace(/"/g, '""');
                    const cleanGenre = (review.song_genre || '').replace(/"/g, '""');
                    const cleanMood = (review.song_mood || '').replace(/"/g, '""');
                    const cleanInstrumentation = (review.song_instrumentation || '').replace(/"/g, '""');
                    
                    // Convert review score to proper decimal format (1/4 -> 1.0, 0.5/4 -> 0.5)
                    let reviewScore = review.review_score;
                    if (reviewScore && typeof reviewScore === 'string' && reviewScore.includes('/')) {
                        const [numerator, denominator] = reviewScore.split('/');
                        if (denominator === '4') {
                            reviewScore = parseFloat(numerator).toFixed(1);
                        }
                    }
                    
                    const qualityStatus = isValid ? 'VALID' : `INVALID: ${validation.errors.join(', ')}`;
                    csvData.push(`"${cleanTitle}","${cleanArtist}","${review.song_release_date || ''}","${review.song_upload_date || ''}","${review.song_duration_sec || ''}","${cleanAlbum}","${cleanLabel}","${cleanGenre}","${cleanMood}","${cleanInstrumentation}","${review.song_language || ''}","${review.song_audio_url || ''}","${review.review_date || ''}","${reviewScore || ''}","${cleanText}","${review.review_id || ''}","${qualityStatus}"`);
                });
                
                // Add data quality summary at the top
                csvData.unshift(`# Data Quality Report - ${new Date().toISOString()}`);
                csvData.unshift(`# Total Reviews: ${validationResults.total}, Valid: ${validationResults.valid}, Invalid: ${validationResults.invalid}`);
                if (validationResults.issues.length > 0) {
                    csvData.unshift(`# Issues Found: ${validationResults.issues.map(i => `Review ${i.index}: ${i.errors.join(', ')}`).join('; ')}`);
                }
                csvData.unshift('');
                
                // Create and download CSV with proper headers
                const csv = csvData.join('\n');
                const blob = new Blob(['\ufeff' + csv], { 
                    type: 'text/csv;charset=utf-8;' 
                });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ope_reviews_comprehensive_with_quality_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                // Successfully exported reviews to CSV
                
            } catch (error) {
                // Track error analytics
                analyticsData.performanceMetrics.totalRequests++;
                saveAnalyticsData();
                
                alert('Error exporting comprehensive reviews. Please try again.');
            }
        }

        /**
         * Search songs by artist name or song title
         * Supports multi-term search with optimized performance
         */
        function searchSongs() {
            const searchTerm = document.getElementById('song-search').value.toLowerCase().trim();
            const songEntries = document.querySelectorAll('.song-entry[data-artist]');
            
            // Track search for analytics (only if there's a search term)
            if (searchTerm) {
                analyticsData.searches.push({
                    term: searchTerm,
                    timestamp: new Date().toISOString(),
                    results: 0 // Will be updated below
                });
            }
            
            // Early return for empty search
            if (!searchTerm) {
                songEntries.forEach(entry => entry.style.display = 'block');
                hideNoResultsMessage();
                return;
            }
            
            // Split search into individual terms and filter out empty ones
            const searchTerms = searchTerm.split(/\s+/).filter(term => term.length > 0);
            let visibleCount = 0;
            
            songEntries.forEach(entry => {
                const artistText = entry.getAttribute('data-artist');
                const titleText = entry.querySelector('.song-title').textContent.toLowerCase();
                const combinedText = `${artistText} ${titleText}`;
                
                // Check if ALL search terms appear in the combined text
                const shouldShow = searchTerms.every(term => combinedText.includes(term));
                
                entry.style.display = shouldShow ? 'block' : 'none';
                if (shouldShow) visibleCount++;
            });
            
            // Update search results count in analytics
            if (analyticsData.searches.length > 0) {
                analyticsData.searches[analyticsData.searches.length - 1].results = visibleCount;
            }
            
            // Save analytics data
            saveAnalyticsData();
            
            // Show/hide "no results" message
            if (visibleCount === 0) {
                showNoResultsMessage();
            } else {
                hideNoResultsMessage();
            }
        }
        
        /**
         * Show the "no results" message
         */
        function showNoResultsMessage() {
            let noResultsMsg = document.getElementById('no-results-msg');
            if (!noResultsMsg) {
                noResultsMsg = document.createElement('p');
                noResultsMsg.id = 'no-results-msg';
                noResultsMsg.className = 'no-results';
                noResultsMsg.textContent = 'No results, sad.';
                
                const searchSection = document.querySelector('.search-section');
                if (searchSection) {
                    searchSection.appendChild(noResultsMsg);
                }
            }
            noResultsMsg.style.display = 'block';
        }
        
        /**
         * Hide the "no results" message
         */
        function hideNoResultsMessage() {
            const noResultsMsg = document.getElementById('no-results-msg');
            if (noResultsMsg) {
                noResultsMsg.style.display = 'none';
            }
        }

        // Show free page by default
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved analytics data
            loadAnalyticsData();
            
            // Check if there's a hash in the URL for direct navigation
            handleHashNavigation();
            
            // Show default page
            showContent('free');

            // Fetch data from API on load
            fetchDataFromAPI();
        });

        // Function to share a song by copying its direct link to clipboard
        // Creates a unique URL with hash navigation for each song
        function shareSong(songId, songTitle) {
            const currentUrl = window.location.href.split('#')[0];
            const shareUrl = `${currentUrl}#${songId}`;
            
            // Simply copy the direct link to clipboard
            copyToClipboard(songId, songTitle, shareUrl);
        }
        

        
        // Function to copy link to clipboard
        function copyToClipboard(songId, songTitle, shareUrl) {
            const doSuccessUI = () => {
                // Show success message
                const shareBtn = document.querySelector(`#${songId} .share-btn`);
                
                if (shareBtn) {
                    const originalText = shareBtn.textContent;
                    shareBtn.textContent = '✅ Link Copied!';
                    shareBtn.classList.add('copied');
                    
                    setTimeout(() => {
                        shareBtn.textContent = originalText;
                        shareBtn.classList.remove('copied');
                    }, 2000);
                }
            };

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl).then(doSuccessUI).catch(() => {
                    // Fallback below
                    try {
                        const ta = document.createElement('textarea');
                        ta.value = shareUrl;
                        ta.setAttribute('readonly', '');
                        ta.style.position = 'absolute';
                        ta.style.left = '-9999px';
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                        doSuccessUI();
                    } catch (err2) {
                        alert('Link: ' + shareUrl);
                    }
                });
            } else {
                // Fallback for insecure contexts
                try {
                    const ta = document.createElement('textarea');
                    ta.value = shareUrl;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'absolute';
                    ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    doSuccessUI();
                } catch (err3) {
                    alert('Link: ' + shareUrl);
                }
            }
        }
        




        // Function to handle hash navigation
        function handleHashNavigation() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                // All reviews go to the songs tab
                showContent('free');
                
                // Wait for API data to load, then scroll to element
                const waitForElement = () => {
                    const targetElement = document.getElementById(hash);
                    if (targetElement) {
                        // Scroll to element
                        targetElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center' 
                        });
                        
                        // Add a subtle highlight effect
                        targetElement.style.boxShadow = '0 0 20px rgba(0,123,255,0.3)';
                        setTimeout(() => {
                            targetElement.style.boxShadow = '';
                        }, 2000);
                    } else if (reviewsData.length > 0) {
                        // Element should exist now, try again
                        setTimeout(waitForElement, 100);
                    } else {
                        // Still loading, wait longer
                        setTimeout(waitForElement, 500);
                    }
                };
                
                waitForElement();
            }
        }

        // Listen for hash changes
        window.addEventListener('hashchange', handleHashNavigation);

        // Modal functions
        function openDataQualityModal() {
            const modal = document.getElementById('data-quality-modal');
            const modalBody = document.getElementById('modal-body');
            
            // Generate and populate modal content
            modalBody.innerHTML = generateDataQualityDashboard();
            
            // Show modal
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
            
            // Focus management
            const closeBtn = modal.querySelector('.modal-close');
            closeBtn.focus();
        }

        function closeDataQualityModal() {
            const modal = document.getElementById('data-quality-modal');
            modal.style.display = 'none';
            document.body.style.overflow = ''; // Restore scrolling
        }

        // Close modal when clicking outside
        document.getElementById('data-quality-modal').addEventListener('click', (e) => {
            if (e.target.id === 'data-quality-modal') {
                closeDataQualityModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('data-quality-modal');
                if (modal.style.display === 'flex') {
                    closeDataQualityModal();
                }
            }
        });

        // Back to top functionality
        const backToTopBtn = document.getElementById('back-to-top');
        
        // Show/hide button based on scroll position
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopBtn.classList.add('show');
            } else {
                backToTopBtn.classList.remove('show');
            }
        });
        
        // Smooth scroll to top when clicked
        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        
        // Keyboard navigation for tabs
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                const tabs = document.querySelectorAll('.nav a[role="tab"]');
                const currentTab = document.querySelector('.nav a[aria-selected="true"]');
                const currentIndex = Array.from(tabs).indexOf(currentTab);
                
                let nextIndex;
                if (e.key === 'ArrowRight') {
                    nextIndex = (currentIndex + 1) % tabs.length;
                } else {
                    nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                }
                
                const nextTab = tabs[nextIndex];
                const page = nextTab.getAttribute('onclick').match(/'([^']+)'/)[1];
                showContent(page);
                nextTab.focus();
                e.preventDefault();
            }
        });

        /**
         * Load Billboard Watch data
         * This demonstrates real-time data integration capabilities
         */
        async function loadBillboardData() {
            const container = document.getElementById('content-container');
            if (!container) {
                console.error('Content container not found! Looking for: content-container');
                return;
            }
            
            // Show loading state
            container.innerHTML = `
                <div class="section">
                                            <h2><strong>Billboard Hot 100 Tracker</strong><br><em>Loading...</em></h2>
                    <p>This tab tracks <a href="https://www.billboard.com/charts/hot-100/" target="_blank">Billboard's official Hot 100 chart</a>, which updates every Tuesday morning pending any holidays or special cases.</p>
                    <div class="loading-spinner">🔄 Loading chart data...</div>
                </div>
            `;
            
            try {
                // Automatically detect environment and use appropriate API endpoint
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const apiUrl = isLocalhost ? 'http://localhost:8000/api/billboard' : '/api/billboard';
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to load Billboard data');
                }
                
                const billboardData = result.data.chart_entries;
                const topArtists = result.data.top_artists;
                const chartDate = result.data.chart_date;

                
                if (!billboardData || billboardData.length === 0) {
                    throw new Error('No chart data found');
                }
                

                
                // Format the date to "August 21, 2025" format
                const formatDate = (dateString) => {
                    const date = new Date(dateString);
                    const options = { year: 'numeric', month: 'long', day: 'numeric' };
                    return date.toLocaleDateString('en-US', options);
                };
                
                const formattedDate = formatDate(chartDate);
                
                const billboardHTML = `
                    <div class="section">
                        <h2>Billboard Hot 100 Tracker</h2>
                        <p><em>Last updated: ${formattedDate}</em></p>
                        <p>This tab tracks <a href="https://www.billboard.com/charts/hot-100/" target="_blank">Billboard's official Hot 100 chart</a>, which updates every Tuesday morning pending any holidays or special cases.</p>
                        
                        <div class="top-artists-summary">
                            <h3>🏆 Top Artists This Week</h3>
                            <ul class="top-artists-list">
                                ${topArtists.slice(0, 5).map(artist => `
                                    <li><strong>#${artist.rank} ${artist.artist}</strong> - ${artist.total_score} pts (${artist.songs_count} songs at positions ${artist.chart_positions.join(', ')})</li>
                                `).join('')}
                            </ul>
                            <p class="scoring-note">Artists are ranked by total points earned across all their chart entries. Rank #1 = 100 points, Rank #2 = 99 points, and so on. This rewards artists with multiple high-charting songs.</p>
                        </div>

                        <div class="billboard-chart">
                            <h3>The Billboard Hot 100 Chart</h3>
                            ${billboardData.map((song, index) => `
                                <div class="chart-entry" data-rank="${song.rank}">
                                    <div class="rank-number">${song.rank}</div>
                                    <div class="song-info">
                                        <h4 class="song-title">${song.title}</h4>
                                        <p class="song-artist">${song.artist}</p>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                container.innerHTML = billboardHTML;
                
            } catch (error) {
                console.error('Error loading Billboard data:', error);
                
                // Fallback to mock data if API fails
                const fallbackData = generateMockBillboardData();
                const fallbackHTML = `
                    <div class="section">
                        <h2><strong>Billboard Hot 100 Tracker</strong><br><em>Error</em></h2>
                        <p>This tab tracks <a href="https://www.billboard.com/charts/hot-100/" target="_blank">Billboard's official Hot 100 chart</a>, which updates every Tuesday morning pending any holidays or special cases.</p>
                        
                        <div class="data-source-info">
                            <h3>⚠️ Data Source Note</h3>
                            <p>Live Billboard data is temporarily unavailable. This demonstrates error handling 
                            and fallback mechanisms in data integration systems.</p>
                            <p><strong>Error:</strong> ${error.message}</p>
                        </div>

                        <div class="billboard-chart">
                            <h3>The Billboard Hot 100 Chart</h3>
                            ${fallbackData.map((song, index) => `
                                <div class="chart-entry" data-rank="${index + 1}">
                                    <div class="rank-number">${index + 1}</div>
                                    <div class="song-info">
                                        <h4 class="song-title">${song.title}</h4>
                                        <p class="song-artist">${song.artist}</p>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                container.innerHTML = fallbackHTML;
            }
        }

        /**
         * Parse Billboard Watch HTML to extract chart data
         * This function scrapes the actual Billboard website structure
         */
        function parseBillboardHTML(html) {
            try {
                
                // Create a DOM parser to extract data from the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                

                
                // Billboard's current structure - let's be more specific
                let chartEntries = [];
                
                // Method 1: Look for the actual chart entries with more specific selectors
                // Billboard uses specific data attributes and classes for chart items
                const chartItems = doc.querySelectorAll('[data-testid*="chart-entry"], [data-testid*="chart-item"], .chart-list-item, .chart-element, .chart-item, .chart-list__item, .chart-list-item, .chart-element__container');
                
                console.log(`Found ${chartItems.length} potential chart items`);
                
                // Try the specific Billboard selector we know works
                const billboardRows = doc.querySelectorAll('.o-chart-results-list-row-container');
                console.log(`Found ${billboardRows.length} Billboard chart rows using .o-chart-results-list-row-container`);
                
                if (billboardRows.length > 0) {
                    console.log('First row HTML structure:', billboardRows[0].outerHTML.substring(0, 500));
                }
                
                if (chartItems.length > 0) {
                    console.log('Processing chart items...');
                    chartItems.forEach((item, index) => {
                        if (index >= 100) return;
                        console.log(`Processing chart item ${index}...`);
                        
                        // Look for song title and artist in the chart item
                        const titleElement = item.querySelector('h3, h4, .chart-element__title, .chart-list-item__title, .title, [class*="title"], .chart-element__text, .chart-list-item__text');
                        const artistElement = item.querySelector('p, .chart-element__artist, .chart-list-item__artist, .artist, [class*="artist"], .chart-element__subtitle, .chart-list-item__subtitle');
                        
                        if (titleElement && artistElement) {
                            const title = titleElement.textContent.trim();
                            const artist = artistElement.textContent.trim();
                            
                            // Filter out navigation items and menu text
                            if (title && artist && 
                                !title.includes('Expand') && 
                                !title.includes('menu') && 
                                !title.includes('Charts') &&
                                !title.includes('Global') &&
                                !title.includes('Afrobeats') &&
                                !title.includes('Greatest') &&
                                !title.includes('Pop') &&
                                !title.includes('Country') &&
                                !title.includes('Rock') &&
                                !title.includes('R&B') &&
                                !title.includes('Latin') &&
                                !title.includes('Dance') &&
                                !title.includes('Christian') &&
                                !title.includes('Gospel') &&
                                !title.includes('Holiday') &&
                                !title.includes('International') &&
                                !title.includes('Regional') &&
                                !title.includes('Billboard') &&
                                !title.includes('THE WEEK') &&
                                !title.includes('MOST POPULAR') &&
                                !title.includes('CURRENT SONGS') &&
                                !title.includes('ACROSS ALL GENRES') &&
                                !title.includes('RANKED BY') &&
                                !title.includes('STREAMING') &&
                                !title.includes('DIGITAL MUSIC') &&
                                !title.includes('LUMINATE') &&
                                !title.includes('RADIO AIRPLAY') &&
                                !title.includes('AUDIENCE IMPRESSIONS') &&
                                !title.includes('SALES DATA') &&
                                !title.includes('COMPILED BY') &&
                                !title.includes('click to see more') &&
                                !title.includes('Biggest gain') &&
                                !title.includes('Gains In Performance') &&
                                !title.includes('A.Warren') &&
                                !title.includes('A.Yaron') &&
                                !title.includes('C.Shapiro') &&
                                !title.includes('Mags Duval')) {
                                
                                chartEntries.push({
                                    title: title,
                                    artist: artist,
                                    rank: index + 1,
                                    weeks: 'N/A',
                                    peak: 'N/A'
                                });
                            }
                        }
                    });
                }
                
                // Process the Billboard rows directly - this is the correct approach
                if (billboardRows.length > 0 && chartEntries.length === 0) {
                    console.log('Processing Billboard rows directly...');
                    billboardRows.forEach((row, index) => {
                        if (index >= 100) return;
                        console.log(`Processing Billboard row ${index}...`);
                        
                        // Extract data from each Billboard row
                        const rankElement = row.querySelector('li:first-child .c-label');
                        const rankText = rankElement ? rankElement.textContent.trim() : '';
                        const rank = rankText ? parseInt(rankText) : (index + 1);
                        
                        const titleElement = row.querySelector('h3.c-title');
                        const title = titleElement ? titleElement.textContent.trim() : '';
                        
                        // More specific artist selector - look for artist links, not date links
                        let artist = '';
                        const allArtistLinks = row.querySelectorAll('.c-label a');
                        allArtistLinks.forEach((link, linkIndex) => {
                            const text = link.textContent.trim();
                            // Filter out dates, numbers, and navigation text
                            if (text && 
                                text.length > 2 && 
                                !text.match(/^\d{2}\/\d{2}\/\d{2}$/) && // Not date format
                                !text.match(/^\d+$/) && // Not just numbers
                                !text.includes('Expand') &&
                                !text.includes('menu') &&
                                !text.includes('Search') &&
                                !text.includes('Plus Icon') &&
                                !text.includes('Account') &&
                                !text.includes('LOGIN') &&
                                !text.includes('Log Out') &&
                                !text.includes('All Charts') &&
                                !text.includes('Week of') &&
                                !text.includes('Datepicker')) {
                                artist = text;
                            }
                        });
                        
                        console.log(`Row ${index}: Rank="${rankText}", Title="${title}", Artist="${artist}"`);
                        
                        // Only add if we have valid song data
                        if (title && artist && 
                            title.length > 2 && 
                            artist.length > 2 &&
                            !title.includes('Expand') &&
                            !title.includes('menu') &&
                            !title.includes('Search') &&
                            !title.includes('Plus Icon') &&
                            !title.includes('Account') &&
                            !title.includes('LOGIN') &&
                            !title.includes('Log Out') &&
                            !title.includes('All Charts') &&
                            !title.includes('Week of') &&
                            !title.includes('Datepicker')) {
                            
                            chartEntries.push({
                                title: title,
                                artist: artist,
                                rank: rank,
                                weeks: 'N/A',
                                peak: 'N/A'
                            });
                            
                            console.log(`Row ${index}: Added song "${title}" by ${artist} at rank ${rank}`);
                        } else {
                            console.log(`Row ${index}: Skipped - invalid data (title: "${title}", artist: "${artist}")`);
                        }
                    });
                    
                    console.log(`Successfully processed ${billboardRows.length} Billboard rows, found ${chartEntries.length} valid songs`);
                }
                
                // Method 2: Look for the main chart content area
                if (chartEntries.length === 0) {
                    console.log('Trying alternative parsing method...');
                    
                    // Look for the main chart content
                    const mainContent = doc.querySelector('main, .main-content, .chart-content, [role="main"]');
                    if (mainContent) {
                        // Look for song entries within the main content
                        const songEntries = mainContent.querySelectorAll('article, .song-entry, .chart-entry, [class*="entry"]');
                        
                        songEntries.forEach((entry, index) => {
                            if (index >= 100) return;
                            
                            const title = entry.querySelector('h3, h4, .song-title, .title');
                            const artist = entry.querySelector('p, .artist, .song-artist');
                            
                            if (title && artist) {
                                const titleText = title.textContent.trim();
                                const artistText = artist.textContent.trim();
                                
                                // Additional filtering for actual song data
                                if (titleText && artistText && 
                                    titleText.length > 2 && 
                                    artistText.length > 2 &&
                                    !titleText.includes('Expand') &&
                                    !titleText.includes('menu')) {
                                    
                                    chartEntries.push({
                                        title: titleText,
                                        artist: artistText,
                                        rank: index + 1,
                                        weeks: 'N/A',
                                        peak: 'N/A'
                                    });
                                }
                            }
                        });
                    }
                }
                
                // Method 2.5: Look for chart ranking numbers and associated content
                if (chartEntries.length === 0) {
                    console.log('Trying ranking-based parsing...');
                    
                    // Look for elements that contain ranking numbers (1, 2, 3, etc.)
                    const rankingElements = doc.querySelectorAll('span, div, h3, h4');
                    const rankingData = [];
                    
                    rankingElements.forEach(element => {
                        const text = element.textContent.trim();
                        // Look for ranking numbers (1-100)
                        const rankMatch = text.match(/^(\d{1,2}|100)$/);
                        if (rankMatch) {
                            const rank = parseInt(rankMatch[1]);
                            if (rank >= 1 && rank <= 100) {
                                // Find the parent container or nearby elements for title/artist
                                const container = element.closest('article, .chart-item, .chart-entry, [class*="chart"], [class*="entry"]') || element.parentElement;
                                if (container) {
                                    const titleElement = container.querySelector('h3, h4, .title, [class*="title"]');
                                    const artistElement = container.querySelector('p, .artist, [class*="artist"]');
                                    
                                    if (titleElement && artistElement) {
                                        const title = titleElement.textContent.trim();
                                        const artist = artistElement.textContent.trim();
                                        
                                        if (title && artist && 
                                            !title.includes('Expand') && 
                                            !title.includes('menu') &&
                                            title.length > 2 && 
                                            artist.length > 2) {
                                            
                                            rankingData.push({
                                                rank: rank,
                                                title: title,
                                                artist: artist,
                                                weeks: 'N/A',
                                                peak: 'N/A'
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    });
                    
                    // Sort by rank and add to chart entries
                    if (rankingData.length > 0) {
                        rankingData.sort((a, b) => a.rank - b.rank);
                        chartEntries = rankingData;
                        console.log(`Found ${rankingData.length} entries using ranking-based parsing`);
                    }
                }
                
                // Method 2.6: Look for the actual chart content by finding chart-specific containers
                if (chartEntries.length === 0) {
                    console.log('Trying chart-container parsing...');
                    
                    // Look for elements that might contain the actual chart
                    const chartContainers = doc.querySelectorAll('[class*="chart"], [class*="list"], [class*="ranking"], [class*="hot-100"], [class*="billboard"], article, section');
                    let foundChartData = false;
                    
                    chartContainers.forEach(container => {
                        if (foundChartData) return;
                        
                        const containerText = container.textContent.toLowerCase();
                        
                        // Check if this container looks like it contains chart data
                        if (containerText.includes('hot 100') || 
                            containerText.includes('billboard') || 
                            containerText.includes('chart') ||
                            containerText.includes('ranking') ||
                            containerText.includes('top 100') ||
                            containerText.includes('weekly chart')) {
                            
                            console.log('Found potential chart container:', container.className);
                            
                            // Look for the actual chart list - Billboard uses specific structures
                            const chartList = container.querySelector('.chart-list, .chart-container, .chart-entries, [class*="chart-list"], [class*="chart-entries"]');
                            
                            if (chartList) {
                                console.log('Found chart list container');
                                
                                // Look for individual chart entries
                                const chartEntries = chartList.querySelectorAll('.chart-entry, .chart-item, .chart-list-item, [class*="chart-entry"], [class*="chart-item"]');
                                
                                if (chartEntries.length > 0) {
                                    console.log(`Found ${chartEntries.length} individual chart entries`);
                                    
                                    chartEntries.forEach((entry, index) => {
                                        if (index >= 100) return;
                                        
                                        // Look for song title and artist within each entry
                                        const titleElement = entry.querySelector('h3, h4, .title, .song-title, .chart-title, [class*="title"]');
                                        const artistElement = entry.querySelector('p, .artist, .song-artist, .chart-artist, [class*="artist"]');
                                        
                                        if (titleElement && artistElement) {
                                            const title = titleElement.textContent.trim();
                                            const artist = artistElement.textContent.trim();
                                            
                                            // Filter out metadata and non-song content
                                            if (title && artist && 
                                                title.length > 2 && 
                                                artist.length > 2 &&
                                                !title.includes('Gains in Weekly Performance') &&
                                                !title.includes('Additional Awards') &&
                                                !title.includes('Debut Chart Date') &&
                                                !title.includes('Peak Position') &&
                                                !title.includes('Peak Chart Date') &&
                                                !title.includes('Chart History') &&
                                                !title.includes('Share') &&
                                                !title.includes('Awards') &&
                                                !title.includes('Credits') &&
                                                !title.includes('Songwriter') &&
                                                !title.includes('Producer') &&
                                                !title.includes('Imprint') &&
                                                !title.includes('Label') &&
                                                !title.includes('RIAA') &&
                                                !title.includes('Certification') &&
                                                !artist.includes('Gains In Performance') &&
                                                !artist.includes('Biggest gain') &&
                                                !artist.includes('airplay') &&
                                                !artist.includes('streams') &&
                                                !artist.includes('sales') &&
                                                !artist.includes('Republic') &&
                                                !artist.includes('Atlantic') &&
                                                !artist.includes('Def Jam') &&
                                                !artist.includes('ILH') &&
                                                !artist.includes('JRC')) {
                                                
                                                chartEntries.push({
                                                    title: title,
                                                    artist: artist,
                                                    rank: index + 1,
                                                    weeks: 'N/A',
                                                    peak: 'N/A'
                                                });
                                            }
                                        }
                                    });
                                    
                                    if (chartEntries.length > 0) {
                                        foundChartData = true;
                                        console.log(`Successfully extracted ${chartEntries.length} chart entries from chart list`);
                                    }
                                }
                            }
                            
                            // If no chart list found, try alternative approach
                            if (!foundChartData) {
                                console.log('No chart list found, trying alternative approach...');
                                
                                // Look for elements that look like song titles (not metadata)
                                const allTextElements = container.querySelectorAll('h3, h4, p, span, div');
                                const potentialSongs = [];
                                
                                allTextElements.forEach(element => {
                                    const text = element.textContent.trim();
                                    
                                    // Look for text that could be actual song titles
                                    if (text && 
                                        text.length > 3 && 
                                        text.length < 100 &&
                                        !text.includes('Gains in Weekly Performance') &&
                                        !text.includes('Additional Awards') &&
                                        !text.includes('Debut Chart Date') &&
                                        !text.includes('Peak Position') &&
                                        !text.includes('Peak Chart Date') &&
                                        !text.includes('Chart History') &&
                                        !text.includes('Share') &&
                                        !text.includes('Awards') &&
                                        !text.includes('Credits') &&
                                        !text.includes('Songwriter') &&
                                        !text.includes('Producer') &&
                                        !text.includes('Imprint') &&
                                        !text.includes('Label') &&
                                        !text.includes('RIAA') &&
                                        !text.includes('Certification') &&
                                        !text.includes('Expand') &&
                                        !text.includes('menu') &&
                                        !text.includes('Search') &&
                                        !text.includes('Plus Icon') &&
                                        !text.includes('Account') &&
                                        !text.includes('LOGIN')) {
                                        
                                        potentialSongs.push(text);
                                    }
                                });
                                
                                // Take the first 100 potential songs and pair them with artists
                                for (let i = 0; i < Math.min(potentialSongs.length, 100); i += 2) {
                                    if (potentialSongs[i] && potentialSongs[i + 1]) {
                                        chartEntries.push({
                                            title: potentialSongs[i],
                                            artist: potentialSongs[i + 1],
                                            rank: Math.floor(i / 2) + 1,
                                            weeks: 'N/A',
                                            peak: 'N/A'
                                        });
                                    }
                                }
                                
                                if (chartEntries.length > 0) {
                                    foundChartData = true;
                                    console.log(`Successfully extracted ${chartEntries.length} chart entries using alternative approach`);
                                }
                            }
                        }
                    });
                }
                
                // Method 2.7: Target Billboard's exact chart structure based on the HTML we found
                if (chartEntries.length === 0) {
                    console.log('Trying Billboard-specific structure parsing...');
                    
                    // Look for Billboard's specific chart row containers
                    const chartRows = doc.querySelectorAll('.o-chart-results-list-row-container');
                    
                    if (chartRows.length > 0) {
                        console.log(`Found ${chartRows.length} Billboard chart rows`);
                        
                        chartRows.forEach((row, index) => {
                            if (index >= 100) return;
                            
                            // Find the rank number - it's in the first li element with a c-label span
                            const rankElement = row.querySelector('li:first-child .c-label');
                            const rankText = rankElement ? rankElement.textContent.trim() : '';
                            const rank = rankText ? parseInt(rankText) : (index + 1);
                            
                            console.log(`Row ${index}: RANK EXTRACTION:`);
                            console.log(`  rankElement found: ${!!rankElement}`);
                            console.log(`  rankText: "${rankText}"`);
                            console.log(`  parsed rank: ${rank}`);
                            console.log(`  fallback index: ${index + 1}`);
                            
                            // Debug the first li element specifically
                            const firstLi = row.querySelector('li:first-child');
                            if (firstLi) {
                                console.log(`  First li classes: "${firstLi.className}"`);
                                const firstLiLabels = firstLi.querySelectorAll('.c-label');
                                console.log(`  First li has ${firstLiLabels.length} .c-label elements`);
                                firstLiLabels.forEach((label, i) => {
                                    console.log(`    Label[${i}]: "${label.textContent.trim()}"`);
                                });
                            }
                            
                            // Debug: show all li elements and their content
                            const allLiElements = row.querySelectorAll('li');
                            console.log(`Row ${index}: Found ${allLiElements.length} li elements`);
                            allLiElements.forEach((li, liIndex) => {
                                const labels = li.querySelectorAll('.c-label');
                                console.log(`  li[${liIndex}]: has ${labels.length} .c-label elements`);
                                labels.forEach((label, labelIndex) => {
                                    console.log(`    label[${labelIndex}]: "${label.textContent.trim()}"`);
                                });
                            });
                            
                            // Try alternative rank selector - look for the first li with a c-label that contains a number
                            if (!rankText || isNaN(rank)) {
                                console.log(`Row ${index}: Trying alternative rank selector...`);
                                const firstLi = row.querySelector('li:first-child');
                                if (firstLi) {
                                    const firstLiLabels = firstLi.querySelectorAll('.c-label');
                                    console.log(`Row ${index}: First li has ${firstLiLabels.length} labels`);
                                    firstLiLabels.forEach((label, labelIndex) => {
                                        const text = label.textContent.trim();
                                        console.log(`Row ${index}: First li label[${labelIndex}]: "${text}"`);
                                        if (text && !isNaN(parseInt(text))) {
                                            console.log(`Row ${index}: Found numeric rank: ${text}`);
                                        }
                                    });
                                }
                            }
                            
                            // Try alternative rank selector - look for the first li with a c-label that contains a number
                            if (!rankText || isNaN(rank)) {
                                console.log(`Row ${index}: Trying alternative rank selector...`);
                                const firstLi = row.querySelector('li:first-child');
                                if (firstLi) {
                                    const firstLiLabels = firstLi.querySelectorAll('.c-label');
                                    console.log(`Row ${index}: First li has ${firstLiLabels.length} labels`);
                                    firstLiLabels.forEach((label, labelIndex) => {
                                        const text = label.textContent.trim();
                                        console.log(`Row ${index}: First li label[${labelIndex}]: "${text}"`);
                                        if (text && !isNaN(parseInt(text))) {
                                            console.log(`Row ${index}: Found numeric rank: ${text}`);
                                        }
                                    });
                                }
                            }
                            
                            // Try alternative rank selector - look for the first li with a c-label that contains a number
                            if (!rankText || isNaN(rank)) {
                                console.log(`Row ${index}: Trying alternative rank selector...`);
                                const firstLi = row.querySelector('li:first-child');
                                if (firstLi) {
                                    const firstLiLabels = firstLi.querySelectorAll('.c-label');
                                    console.log(`Row ${index}: First li has ${firstLiLabels.length} labels`);
                                    firstLiLabels.forEach((label, labelIndex) => {
                                        const text = label.textContent.trim();
                                        console.log(`Row ${index}: First li label[${labelIndex}]: "${text}"`);
                                        if (text && !isNaN(parseInt(text))) {
                                            console.log(`Row ${index}: Found numeric rank: ${text}`);
                                        }
                                    });
                                }
                            }
                            
                            // Try alternative rank selector - look for the first li with a c-label that contains a number
                            if (!rankText || isNaN(rank)) {
                                console.log(`Row ${index}: Trying alternative rank selector...`);
                                const firstLi = row.querySelector('li:first-child');
                                if (firstLi) {
                                    const firstLiLabels = firstLi.querySelectorAll('.c-label');
                                    console.log(`Row ${index}: First li has ${firstLiLabels.length} labels`);
                                    firstLiLabels.forEach((label, labelIndex) => {
                                        const text = label.textContent.trim();
                                        console.log(`Row ${index}: First li label[${labelIndex}]: "${text}"`);
                                        if (text && !isNaN(parseInt(text))) {
                                            console.log(`Row ${index}: Found numeric rank: ${text}`);
                                        }
                                    });
                                }
                            }
                            
                            // Find the song title - look for h3 with c-title class specifically
                            const titleElement = row.querySelector('h3.c-title');
                            const title = titleElement ? titleElement.textContent.trim() : '';
                            
                            // Find the artist name - look for .c-label a that's NOT in the first li (rank)
                            let artist = '';
                            const allArtistLinks = row.querySelectorAll('.c-label a');
                            allArtistLinks.forEach((link, linkIndex) => {
                                const text = link.textContent.trim();
                                // Skip the first li (which should be the rank) and look for artist links
                                if (text && text.length > 2 && !text.match(/^\d+$/)) {
                                    artist = text;
                                }
                            });
                            
                            // Debug: show exactly what we found
                            console.log(`Row ${index}: FINAL EXTRACTION:`);
                            console.log(`  Rank: ${rank} (${typeof rank})`);
                            console.log(`  Title: "${title}" (${typeof title})`);
                            console.log(`  Artist: "${artist}" (${typeof artist})`);
                            
                            // Additional debugging for the specific HTML structure
                            console.log(`Row ${index}: HTML STRUCTURE ANALYSIS:`);
                            const allH3s = row.querySelectorAll('h3');
                            console.log(`  Found ${allH3s.length} h3 elements:`);
                            allH3s.forEach((h3, i) => {
                                console.log(`    h3[${i}]: class="${h3.className}", text="${h3.textContent.trim()}"`);
                            });
                            
                            const allLinks = row.querySelectorAll('a');
                            console.log(`  Found ${allLinks.length} a elements:`);
                            allLinks.forEach((link, i) => {
                                console.log(`    a[${i}]: href="${link.href}", text="${link.textContent.trim()}"`);
                            });
                            
                            console.log(`Row ${index}: titleElement found: ${!!titleElement}, title: "${title}"`);
                            console.log(`Row ${index}: artistElement found: ${!!artistElement}, artist: "${artist}"`);
                            
                            // Debug: show all h3 elements and their content
                            const allH3Elements = row.querySelectorAll('h3');
                            console.log(`Row ${index}: Found ${allH3Elements.length} h3 elements`);
                            allH3Elements.forEach((h3, h3Index) => {
                                console.log(`  h3[${h3Index}]: "${h3.textContent.trim()}"`);
                            });
                            
                            // Debug: show all .c-label a elements and their content
                            console.log(`Row ${index}: Found ${allArtistLinks.length} .c-label a elements`);
                            allArtistLinks.forEach((link, linkIndex) => {
                                console.log(`  link[${linkIndex}]: "${link.textContent.trim()}"`);
                            });
                            
                            // Try alternative title selector - look for h3 with c-title class
                            if (!title) {
                                console.log(`Row ${index}: Trying alternative title selector...`);
                                const titleH3 = row.querySelector('h3.c-title');
                                if (titleH3) {
                                    console.log(`Row ${index}: Found h3.c-title: "${titleH3.textContent.trim()}"`);
                                }
                            }
                            
                            // Try alternative artist selector - look for .c-label a that's not in the first li
                            if (!artist) {
                                console.log(`Row ${index}: Trying alternative artist selector...`);
                                allArtistLinks.forEach((link, linkIndex) => {
                                    const text = link.textContent.trim();
                                    console.log(`Row ${index}: Artist link[${linkIndex}]: "${text}"`);
                                    // Skip the first li (which should be the rank)
                                    if (linkIndex > 0 && text && text.length > 2) {
                                        console.log(`Row ${index}: Potential artist found: "${text}"`);
                                    }
                                });
                            }
                            
                            // Try alternative title selector - look for h3 with c-title class
                            if (!title) {
                                console.log(`Row ${index}: Trying alternative title selector...`);
                                const titleH3 = row.querySelector('h3.c-title');
                                if (titleH3) {
                                    console.log(`Row ${index}: Found h3.c-title: "${titleH3.textContent.trim()}"`);
                                }
                            }
                            
                            // Try alternative artist selector - look for .c-label a that's not in the first li
                            if (!artist) {
                                console.log(`Row ${index}: Trying alternative artist selector...`);
                                const artistLinks = row.querySelectorAll('.c-label a');
                                artistLinks.forEach((link, linkIndex) => {
                                    const text = link.textContent.trim();
                                    console.log(`Row ${index}: Artist link[${linkIndex}]: "${text}"`);
                                    // Skip the first li (which should be the rank)
                                    if (linkIndex > 0 && text && text.length > 2) {
                                        console.log(`Row ${index}: Potential artist found: "${text}"`);
                                    }
                                });
                            }
                            
                            // Try alternative title selector - look for h3 with c-title class
                            if (!title) {
                                console.log(`Row ${index}: Trying alternative title selector...`);
                                const titleH3 = row.querySelector('h3.c-title');
                                if (titleH3) {
                                    console.log(`Row ${index}: Found h3.c-title: "${titleH3.textContent.trim()}"`);
                                }
                            }
                            
                            // Try alternative artist selector - look for .c-label a that's not in the first li
                            if (!artist) {
                                console.log(`Row ${index}: Trying alternative artist selector...`);
                                const artistLinks = row.querySelectorAll('.c-label a');
                                artistLinks.forEach((link, linkIndex) => {
                                    const text = link.textContent.trim();
                                    console.log(`Row ${index}: Artist link[${linkIndex}]: "${text}"`);
                                    // Skip the first li (which should be the rank)
                                    if (linkIndex > 0 && text && text.length > 2) {
                                        console.log(`Row ${index}: Potential artist found: "${text}"`);
                                    }
                                });
                            }
                            
                            // Find additional stats if available
                            const lwElement = row.querySelector('.o-chart-results-list__item .c-label:contains("LW") + .o-chart-results-list__item .c-label');
                            const peakElement = row.querySelector('.o-chart-results-list__item .c-label:contains("PEAK") + .o-chart-results-list__item .c-label');
                            const weeksElement = row.querySelector('.o-chart-results-list__item .c-label:contains("WEEKS") + .o-chart-results-list__item .c-label');
                            
                            const lw = lwElement ? lwElement.textContent.trim() : 'N/A';
                            const peak = peakElement ? peakElement.textContent.trim() : 'N/A';
                            const weeks = weeksElement ? weeksElement.textContent.trim() : 'N/A';
                            
                            if (title && artist && 
                                title.length > 2 && 
                                artist.length > 2 &&
                                !title.includes('Expand') &&
                                !title.includes('menu') &&
                                !title.includes('Search') &&
                                !title.includes('Plus Icon') &&
                                !title.includes('Account') &&
                                !title.includes('LOGIN')) {
                                
                                chartEntries.push({
                                    title: title,
                                    artist: artist,
                                    rank: rank,
                                    weeks: weeks,
                                    peak: peak
                                });
                                
                                console.log(`Found chart entry: #${rank} "${title}" by ${artist} (${weeks} weeks, peak: ${peak})`);
                            }
                        });
                        
                        if (chartEntries.length > 0) {
                            console.log(`Successfully extracted ${chartEntries.length} chart entries using Billboard structure`);
                        }
                    }
                }
                
                // Method 3: Look for specific Billboard chart patterns
                if (chartEntries.length === 0) {
                    console.log('Trying pattern-based parsing...');
                    
                    // Look for text that looks like song titles (not navigation)
                    const allTextElements = doc.querySelectorAll('h3, h4, p, span');
                    const potentialSongs = [];
                    
                    allTextElements.forEach((element, index) => {
                        if (index >= 200) return; // Limit search
                        
                        const text = element.textContent.trim();
                        
                        // Look for text that could be song titles
                        if (text && 
                            text.length > 3 && 
                            text.length < 100 &&
                            !text.includes('Expand') &&
                            !text.includes('menu') &&
                            !text.includes('Charts') &&
                            !text.includes('Billboard') &&
                            !text.includes('THE WEEK') &&
                            !text.includes('MOST POPULAR') &&
                            !text.includes('CURRENT SONGS') &&
                            !text.includes('ACROSS ALL GENRES') &&
                            !text.includes('RANKED BY') &&
                            !text.includes('STREAMING') &&
                            !text.includes('DIGITAL MUSIC') &&
                            !text.includes('LUMINATE') &&
                            !text.includes('RADIO AIRPLAY') &&
                            !text.includes('AUDIENCE IMPRESSIONS') &&
                            !text.includes('SALES DATA') &&
                            !text.includes('COMPILED BY') &&
                            !text.includes('click to see more') &&
                            !text.includes('Biggest gain') &&
                            !text.includes('Gains In Performance') &&
                            !text.includes('A.Warren') &&
                            !text.includes('A.Yaron') &&
                            !text.includes('C.Shapiro') &&
                            !text.includes('Mags Duval') &&
                            !text.includes('Expand') &&
                            !text.includes('menu') &&
                            !text.includes('Charts') &&
                            !text.includes('Global') &&
                            !text.includes('Afrobeats') &&
                            !text.includes('Greatest') &&
                            !text.includes('Pop') &&
                            !text.includes('Country') &&
                            !text.includes('Rock') &&
                            !text.includes('R&B') &&
                            !text.includes('Latin') &&
                            !text.includes('Dance') &&
                            !text.includes('Christian') &&
                            !text.includes('Gospel') &&
                            !text.includes('Holiday') &&
                            !text.includes('International') &&
                            !text.includes('Regional') &&
                            // Filter out navigation elements
                            !text.includes('Search') &&
                            !text.includes('Plus Icon') &&
                            !text.includes('Click to Close') &&
                            !text.includes('Account') &&
                            !text.includes('Manage Account') &&
                            !text.includes('Log Out') &&
                            !text.includes('LOGIN') &&
                            !text.includes('Login') &&
                            !text.includes('Follow Billboard') &&
                            !text.includes('Facebook') &&
                            !text.includes('Instagram') &&
                            !text.includes('Pinterest') &&
                            !text.includes('X') &&
                            !text.includes('YouTube') &&
                            !text.includes('About Us') &&
                            !text.includes('Accessibility') &&
                            !text.includes('Advertise') &&
                            !text.includes('Shop') &&
                            !text.includes('Events') &&
                            !text.includes('Careers') &&
                            !text.includes('Contact Us') &&
                            !text.includes('Privacy Policy') &&
                            !text.includes('Terms of Use') &&
                            !text.includes('California Privacy Rights') &&
                            !text.includes('Ad Choices') &&
                            !text.includes('Reprints') &&
                            !text.includes('Permissions') &&
                            !text.includes('Privacy Preferences') &&
                            !text.includes('Your Privacy Choices') &&
                            !text.includes('Sitemap') &&
                            !text.includes('Pro') &&
                            !text.includes('Have a Tip') &&
                            !text.includes('Send us a tip') &&
                            !text.includes('The Daily') &&
                            !text.includes('daily briefing') &&
                            !text.includes('music industry') &&
                            !text.includes('Enter Your Email') &&
                            !text.includes('Sign Up') &&
                            !text.includes('By providing your information') &&
                            !text.includes('Terms of Use') &&
                            !text.includes('Privacy Policy') &&
                            !text.includes('reCAPTCHA') &&
                            !text.includes('Google Privacy Policy') &&
                            !text.includes('Terms of Service') &&
                            !text.includes('Powered by WordPress.com VIP') &&
                            !text.includes('Our Sites') &&
                            !text.includes('Art in America') &&
                            !text.includes('Artforum') &&
                            !text.includes('ARTnews') &&
                            !text.includes('BlogHer') &&
                            !text.includes('Deadline') &&
                            !text.includes('Flow Space') &&
                            !text.includes('Gold Derby') &&
                            !text.includes('IndieWire') &&
                            !text.includes('Robb Report') &&
                            !text.includes('Rolling Stone') &&
                            !text.includes('SheKnows') &&
                            !text.includes('Soaps') &&
                            !text.includes('Sourcing Journal') &&
                            !text.includes('Sportico') &&
                            !text.includes('StyleCaster') &&
                            !text.includes('The Hollywood Reporter') &&
                            !text.includes('TVLine') &&
                            !text.includes('Variety') &&
                            !text.includes('Vibe') &&
                            !text.includes('WWD')) {
                            
                            potentialSongs.push(text);
                        }
                    });
                    
                    // Take the first 100 potential songs and pair them with artists
                    for (let i = 0; i < Math.min(potentialSongs.length, 100); i += 2) {
                        if (potentialSongs[i] && potentialSongs[i + 1]) {
                            chartEntries.push({
                                title: potentialSongs[i],
                                artist: potentialSongs[i + 1],
                                rank: Math.floor(i / 2) + 1,
                                weeks: 'N/A',
                                peak: 'N/A'
                            });
                        }
                    }
                }
                
                // Clean and validate the data
                chartEntries = chartEntries.filter(entry => 
                    entry.title && 
                    entry.title.length > 0 && 
                    entry.title.length < 100 &&
                    entry.artist && 
                    entry.artist.length > 0 && 
                    entry.artist.length < 100 &&
                    entry.title !== 'Unknown Title' &&
                    entry.artist !== 'Unknown Artist'
                );
                
                console.log(`After filtering: ${chartEntries.length} chart entries`);
                
                // If we still don't have data, return mock data
                if (chartEntries.length === 0) {
                    console.log('No Billboard data found, using mock data');
                    return generateMockBillboardData();
                }
                
                console.log(`Successfully parsed ${chartEntries.length} Billboard chart entries`);
                
                // Debug: Show what we actually captured
                console.log('First 10 chart entries:', chartEntries.slice(0, 10));
                
                return chartEntries.slice(0, 100); // Ensure we only return top 100
                
            } catch (error) {
                console.error('Error parsing Billboard HTML:', error);
                return generateMockBillboardData();
            }
        }

        /**
         * Generate mock Billboard Watch data for demonstration
         * In production, this would be replaced with real API calls
         */
        function generateMockBillboardData() {
            return [
                { title: "Flowers", artist: "Miley Cyrus", weeks: 8, peak: 1 },
                { title: "Last Night", artist: "Morgan Wallen", weeks: 12, peak: 1 },
                { title: "Kill Bill", artist: "SZA", weeks: 15, peak: 2 },
                { title: "Unholy", artist: "Sam Smith & Kim Petras", weeks: 20, peak: 1 },
                { title: "As It Was", artist: "Harry Styles", weeks: 25, peak: 1 },
                { title: "About Damn Time", artist: "Lizzo", weeks: 18, peak: 3 },
                { title: "Break My Soul", artist: "Beyoncé", weeks: 22, peak: 7 },
                { title: "Late Night Talking", artist: "Harry Styles", weeks: 16, peak: 4 },
                { title: "Hold Me Closer", artist: "Elton John & Britney Spears", weeks: 14, peak: 6 },
                { title: "Vampire", artist: "Olivia Rodrigo", weeks: 12, peak: 5 }
            ];
        }
    </script>

                                                                                                                                                        <!-- Footer -->
<footer class="footer" role="contentinfo">
        
        <div class="footer-content">
            <div class="last-updated">
                <strong>Reviews last updated:</strong> <span id="last-updated-date">Loading...</span> (Los Angeles, CA PST Time). Reviews are published on Fridays unless I'm on vacation or sick.
            </div>
            
            <div class="support-info">
                <strong>Best ways to support:</strong> Bookmark this page, subscribe to the newsletter and podcast, tell all your friends.
            </div>
            
            <div class="contact-info">
                <strong>Don't like my reviews?</strong> Email me at bradywgerber at gmail dot com to tell me why I'm wrong, or hate-click my <a href="https://bradygerber.com/" target="_blank" rel="noopener" class="api-link">website</a>. My reviews don’t reflect the views of all my wonderful clients.
            </div>
            
            <div class="analytics-info">
                <strong>For all my data and Excel nerds:</strong> Check out <a href="https://ope-music.netlify.app/api/reviews" target="_blank" class="api-link">OPE!'s public API</a> and <a href="#" onclick="openDataQualityModal(); return false;" class="analytics-link">download review data as a CSV file</a>. You can also check out OPE! on <a href="https://github.com/bg-write/ope-music" target="_blank" class="api-link">GitHub</a> and <a href="https://lookerstudio.google.com/reporting/86a21abe-e77c-4fda-9b58-423d4a45da2b" target="_blank" class="api-link">Looker Studio</a>, powered by BigQuery.
            </div>
            
            <div class="footer-bottom">
                <img src="images/author.png" alt="Brady Gerber" class="author-image">
                <span class="copyright">&copy; 2025 OPE!. All rights reserved.</span>
            </div>
        </div>
    </footer>
</body>
</html>
